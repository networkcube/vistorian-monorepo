import * as d3 from "d3";
import * as utils from "vistorian-core/src/data/utils";
import * as dynamicgraph from "vistorian-core/src/data/dynamicgraph";
import * as main from "vistorian-core/src/data/main";
const RECT_SIZE = 13;
const INTENT = 0;
const LINE_HEIGHT = 13;
const GAP_ICONS = 3;
const width = window.innerWidth;
// Get data
const dgraph = main.getDynamicGraph();
// We need to register callbacks on the global messenger, or they won't fire
const messenger = window.vc.messenger;
messenger.setDefaultEventListener(updateLists);
messenger.addEventListener("searchResult", searchResultHandler);
// CREATE SEARCH INPUT
// CRETE SELECTION LIST VIEW
// add node selections
createSelectionCategory("Node Selections", "node");
createSelectionCategory("Link Selections", "link");
createViewOnlyCategory("Node Colours", "nodeColor");
createViewOnlyCategory("Node Shapes", "nodeShape");
updateLists();
export function createSelectionCategory(name, type) {
    const nodeDiv = d3
        .select("body")
        .append("div")
        .attr("id", "div_" + type);
    nodeDiv
        .append("p")
        .attr("id", "title_" + type)
        .html(name + ":");
    nodeDiv
        .append("input")
        .datum(type)
        .attr("type", "button")
        .attr("value", "+")
        .attr("onclick", "trace.event('vis_13',document.location.pathname,'add ' ,'" + type + "')")
        .on("click", function (ev, d) {
        createSelection(d);
    });
}
export function createViewOnlyCategory(name, type) {
    const nodeDiv = d3
        .select("body")
        .append("div")
        .attr("id", "divViewOnly_" + type);
    nodeDiv
        .append("p")
        .attr("id", "titleViewOnly_" + type)
        .html(name + ":");
}
export function updateViewOnlyList(type, name) {
    let tmp = [];
    let trimmedColorsNoNulls;
    let trimmedShapesNoNulls;
    if (type == "nodeColor") {
        //Remove duplicates
        const trimmedColors = dgraph.nodeArrays.color.filter(function (v) {
            if (typeof v != "undefined" && v) {
                if (tmp.indexOf(v.toString()) < 0) {
                    tmp.push(v.toString());
                    return v;
                }
            }
        });
        //Remove null/undefinted
        tmp = [];
        trimmedColorsNoNulls = trimmedColors.filter(function (v) {
            if (v[0] != null) {
                return v;
            }
        });
    }
    if (type == "nodeShape") {
        //Remove duplicates
        tmp = [];
        const trimmedShapes = dgraph.nodeArrays.shape.filter(function (v) {
            if (typeof v != "undefined" && v) {
                if (tmp.indexOf(v.toString()) < 0) {
                    tmp.push(v.toString());
                    return v;
                }
            }
        });
        //Remove null/undefinted
        tmp = [];
        trimmedShapesNoNulls = trimmedShapes.filter(function (v) {
            if (v[0] != null) {
                return v;
            }
        });
    }
    d3.select("#divViewOnly_" + type)
        .selectAll(".selectionDiv_" + type)
        .remove();
    const nodeGs = d3
        .select("#divViewOnly_" + type)
        .selectAll(".selectionDiv_" + type)
        .data(function () {
        if (type == "nodeColor") {
            return trimmedColorsNoNulls;
        }
        if (type == "nodeShape") {
            return trimmedShapesNoNulls;
        }
        return [];
    })
        .enter()
        .append("div")
        .attr("class", "selectionDiv_" + type)
        .attr("height", LINE_HEIGHT)
        .append("svg")
        .attr("class", "svg_" + type)
        .attr("height", LINE_HEIGHT)
        .attr("width", width)
        .append("g")
        .attr("transform", "translate(" + INTENT + ",0)");
    d3.selectAll(".selectionDiv_" + type).style("background-color", function (d) {
        if (d) {
            if (dgraph.currentSelection_id == d.id)
                return "#cccccc";
        }
        return "#ffffff";
    });
    if (type == "nodeColor") {
        nodeGs
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", RECT_SIZE)
            .attr("height", RECT_SIZE)
            .style("fill", function (d) {
            return d[1];
        })
            .on("click", function (ev, d) {
            messenger.setSelectionColor(d, "#" + Math.floor(Math.random() * 16777215).toString(16));
        });
    }
    if (type == "nodeShape") {
        nodeGs
            .append("path")
            .attr("transform", function () {
            return "translate(7,7)";
        })
            .attr("d", (n) => d3.symbol().size(40).type(getNodeShape(n))())
            .style("fill", "black");
    }
    nodeGs
        .append("text")
        .attr("class", "selectionLabel")
        .text(function (d) {
        return d[0];
    })
        .style("font-size", RECT_SIZE + "px")
        .style("font-family", "Helvetica")
        .attr("x", RECT_SIZE + 10)
        .attr("y", RECT_SIZE * 0.8)
        .on("click", function (ev, d) {
        messenger.setCurrentSelection(d);
        updateLists();
    });
}
export function createSelection(type) {
    const b = dgraph.createSelection(type); // IS IT OK?? (dgraph)
    window.setTimeout(() => {
        messenger.setCurrentSelection(b);
        updateLists();
    }, 500);
}
export function updateLists() {
    updateList("node", "Node Selections");
    updateList("link", "Link Selections");
    updateViewOnlyList("nodeColor", "Node Colors");
    updateViewOnlyList("nodeShape", "Node Shapes");
    d3.selectAll(".icon_showColor").attr("xlink:href", function (d) {
        if (d.showColor)
            return "drop-full.png";
        return "drop-empty.png";
    });
    d3.selectAll(".icon_eye").attr("xlink:href", function (d) {
        if (d.filter)
            return "eye-blind.png";
        return "eye-seeing.png";
    });
    d3.selectAll(".selectionLabel").text(function (d) {
        return d.name + " (" + d.elementIds.length + ")";
    });
}
export function updateList(type, name) {
    const selections = dgraph.getSelections(type);
    const title = d3.select("#title_" + type);
    title.html(name + " (" + selections.length + ")");
    d3.select("#div_" + type)
        .selectAll(".selectionDiv_" + type)
        .remove();
    const nodeGs = d3
        .select("#div_" + type)
        .selectAll(".selectionDiv_" + type)
        .data(selections.sort(utils.sortByPriority))
        .enter()
        .append("div")
        .attr("class", "selectionDiv_" + type)
        .attr("height", LINE_HEIGHT)
        .append("svg")
        .attr("class", "svg_" + type)
        .attr("height", LINE_HEIGHT)
        .attr("width", width)
        .append("g")
        .attr("transform", "translate(" + INTENT + ",0)");
    d3.selectAll(".selectionDiv_" + type).style("background-color", function (d) {
        if (dgraph.currentSelection_id == d.id)
            return "#cccccc";
        return "#ffffff";
    });
    nodeGs
        .append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", RECT_SIZE)
        .attr("height", RECT_SIZE)
        .style("fill", function (d) {
        return d.color;
    })
        .on("click", function (ev, d) {
        messenger.setSelectionColor(d, "#" + Math.floor(Math.random() * 16777215).toString(16));
    });
    nodeGs
        .append("text")
        .attr("class", "selectionLabel")
        .text(function (d) {
        return d.name;
    })
        .style("font-size", RECT_SIZE + "px")
        .style("font-family", "Helvetica")
        .attr("x", RECT_SIZE + 10)
        .attr("y", RECT_SIZE * 0.8)
        .on("click", function (ev, d) {
        messenger.setCurrentSelection(d);
        updateLists();
    });
    // add pictures
    let i = 0;
    nodeGs
        .append("svg:image")
        .attr("class", "icon_showColor icon")
        .attr("x", 130 + (RECT_SIZE + GAP_ICONS) * i++)
        .on("click", function (ev, d) {
        messenger.showSelectionColor(d, !d.showColor);
    });
    nodeGs
        .append("svg:image")
        .attr("id", "eye_" + name)
        .attr("class", "icon_eye icon")
        .attr("xlink:href", "eye-seeing.png") //eye-visible.png
        .attr("x", 130 + (RECT_SIZE + GAP_ICONS) * i++)
        .attr("onclick", "trace.event('vis_14',document.location.pathname,'" +
        name +
        "' , this.getAttribute('href'))")
        .on("click", function (ev, d) {
        messenger.filterSelection(d, !d.filter);
    });
    nodeGs
        .append("svg:image")
        .filter((d) => {
        return d.name.indexOf("Unselected") == -1;
    })
        .attr("class", "icon")
        .attr("xlink:href", "up.png")
        .attr("x", 130 + (RECT_SIZE + GAP_ICONS) * i++)
        .on("click", function (ev, d, i) {
        if (i > 0)
            messenger.swapPriority(d, (d3.selectAll(".selectionDiv_" + d.acceptedType).data()[i - 1])); // CAST TO SELECTION??
    });
    nodeGs
        .append("svg:image")
        .filter((d) => {
        return d.name.indexOf("Unselected") == -1;
    })
        .attr("class", "icon")
        .attr("xlink:href", "down.png")
        .attr("x", 130 + (RECT_SIZE + GAP_ICONS) * i++)
        .on("click", function (ev, d, i) {
        if (d3.selectAll(".selectionDiv_" + d.acceptedType).data()[i + 1])
            messenger.swapPriority(d, (d3.selectAll(".selectionDiv_" + d.acceptedType).data()[i + 1])); // CAST TO SELECTION??
    });
    nodeGs
        .append("svg:image")
        .filter((d) => {
        return d.name.indexOf("Unselected") == -1;
    })
        .attr("class", "icon")
        .attr("xlink:href", "delete.png")
        .attr("x", 130 + (RECT_SIZE + GAP_ICONS) * i++)
        .on("click", function (ev, d) {
        messenger.deleteSelection(d);
    });
    nodeGs.selectAll(".icon").attr("height", RECT_SIZE).attr("width", RECT_SIZE);
}
let searchMessage;
export function searchResultHandler(m) {
    searchMessage = m;
    const results = document.getElementById("searchResults");
    if (!results) {
        return;
    }
    results.innerHTML = "";
    const row = document.createElement("li");
    results.appendChild(row);
    if (m.idCompound.nodeIds) {
        const p = document.createElement("p");
        row.appendChild(p);
        p.outerHTML =
            '<p class="searchResult">Nodes: <b>' +
                m.idCompound.nodeIds.length +
                "</b> <u onclick=\"saveSearchResultAsSelection('node')\">(Save as selection)</u></p>";
    }
    if (m.idCompound.linkIds) {
        const p = document.createElement("p");
        row.appendChild(p);
        p.outerHTML =
            '<p class="searchResult">Links: <b>' +
                m.idCompound.linkIds.length +
                "</b> <u onclick=\"saveSearchResultAsSelection('link')\">(Save as selection)</u></p>";
    }
}
window.saveSearchResultAsSelection = saveSearchResultAsSelection;
export function saveSearchResultAsSelection(type) {
    const s = messenger.createSelection(type, searchMessage.searchTerm);
    const selectionIdCompound = new dynamicgraph.IDCompound();
    selectionIdCompound[type + "Ids"] = searchMessage.idCompound[type + "Ids"];
    const temp = utils.makeElementCompound(selectionIdCompound, dgraph);
    window.setTimeout(() => {
        messenger.highlight("reset");
        window.setTimeout(() => {
            messenger.selection("set", utils.makeElementCompound(selectionIdCompound, dgraph), s.id);
        }, 1000);
    }, 1000);
}
// clear search field and highlighted nodes
export function clearSearchSelection() {
    messenger.highlight("reset");
    const results = document.getElementById("searchResults");
    if (results) {
        results.innerHTML = "";
    }
}
export function getNodeShape(n) {
    const shapes = {
        circle: d3.symbolCircle,
        cross: d3.symbolCross,
        diamond: d3.symbolDiamond,
        square: d3.symbolSquare,
        star: d3.symbolStar,
        triangle: d3.symbolTriangle,
        wye: d3.symbolWye,
    };
    const tmp = n[1].split(",");
    if (tmp) {
        const shape = tmp[tmp.length - 1];
        return shapes[shape] ? shapes[shape] : d3.symbolCircle;
    }
    return d3.symbolWye;
}
//# sourceMappingURL=bookmarkbrowser.js.map