import { DataSet, Selection } from "./dynamicgraphutils";
import { DataManager } from "./datamanager";
export declare const GRANULARITY: string[];
export declare const DGRAPH_SUB = "[*dgraph*]";
export declare const DGRAPH_SER_VERBOSE_LOGGING = false;
export declare function dgraphReviver(dgraph: DynamicGraph, key: any, value: any): any;
export declare function dgraphReplacer(key: string, value: any): any;
export declare class DynamicGraph {
    private default_colors;
    BOOKMARK_COLORS: (i: number) => string;
    selectionColor_pointer: number;
    name: string;
    gran_min: number;
    gran_max: number;
    minWeight: number;
    maxWeight: number;
    _nodes: Node[];
    _links: Link[];
    directed: boolean;
    _nodePairs: NodePair[];
    _locations: Location[];
    _times: Time[];
    timeObjects: any[];
    nodeOrders: Ordering[];
    matrix: number[][];
    selections: Selection[];
    nodeArrays: NodeArray;
    linkArrays: LinkArray;
    nodePairArrays: NodePairArray;
    timeArrays: TimeArray;
    linkTypeArrays: LinkTypeArray;
    nodeTypeArrays: NodeTypeArray;
    locationArrays: LocationArray;
    attributeArrays: Record<string, any>;
    highlightArrays: IDCompound;
    highlightFreezeArrays: IDCompound;
    currentSelection_id: number;
    defaultLinkSelection: Selection;
    defaultNodeSelection: Selection;
    attr(field: string, id: number, type: string): any;
    gran_min_NAME: string;
    gran_max_NAME: string;
    directed_NAME: string;
    minWeight_NAME: string;
    maxWeight_NAME: string;
    matrix_NAME: string;
    nodeArrays_NAME: string;
    linkArrays_NAME: string;
    nodePairArrays_NAME: string;
    timeArrays_NAME: string;
    linkTypeArrays_NAME: string;
    nodeTypeArrays_NAME: string;
    locationArrays_NAME: string;
    standardArrayReplacer(key: string, value: any): any;
    static timeReviver(k: string, v: any, s: DynamicGraph): any;
    static nodeArrayReviver(k: string, v: any, s: DynamicGraph): any;
    static linkArrayReviver(k: string, v: any, s: DynamicGraph): any;
    static nodePairArrayReviver(k: string, v: any, s: DynamicGraph): any;
    static timeArrayReviver(k: string, v: any, s: DynamicGraph): any;
    static linkTypeArrayReviver(k: string, v: any, s: DynamicGraph): any;
    static nodeTypeArrayReviver(k: string, v: any, s: DynamicGraph): any;
    static locationArrayReviver(k: string, v: any, s: DynamicGraph): any;
    loadDynamicGraph(dataMgr: DataManager, dataSetName: string): void;
    saveDynamicGraph(dataMgr: DataManager): void;
    delete(dataMgr: DataManager): void;
    debugCompareTo(other: DynamicGraph): boolean;
    initDynamicGraph(data: DataSet): void;
    createSelections(shouldCreateArrays: boolean): void;
    /**
     *
     * Returns a window graph for the passed time point
     * or period
     * @param  {any}    start First time point of this graph
     * @param  {any}    end   Last time point of this graph.
     * @return {[type]}       [description]
     */
    private createGraphObjects;
    nodeAttr(attr: string, id: number): any;
    linkAttr(attr: string, id: number): any;
    pairAttr(attr: string, id: number): any;
    timeAttr(attr: string, id: number): any;
    get startTime(): Time;
    get endTime(): Time;
    highlight(action: string, idCompound?: IDCompound): void;
    selection(action: string, idCompound: IDCompound, selectionId?: number): void;
    addToAttributeArraysSelection(selection: Selection, type: string, id: number): void;
    removeFromAttributeArraysSelection(selection: Selection, type: string, id: number): void;
    addElementToSelection(selection: Selection, e: BasicElement): void;
    addToSelectionByTypeAndId(selection: Selection, type: string, id: number): void;
    removeElementFromSelection(selection: Selection, e: BasicElement): void;
    removeFromSelectionByTypeAndId(selection: Selection, type: string, id: number): void;
    getSelectionsByTypeAndId(type: string, id: number): Selection[];
    filterSelection(selectionId: number, filter: boolean): void;
    isFiltered(id: number, type: string): boolean;
    isHighlighted(id: number, type: string): boolean;
    isFrozen(id: number, type: string): boolean;
    getHighlightedIds(type: string): any;
    setCurrentSelection(id: number): void;
    getCurrentSelection(): Selection | undefined;
    addSelection(id: number, color: string, acceptedType: string, priority: number): void;
    createSelection(type: string): Selection;
    deleteSelection(selectionId: number): void;
    setSelectionColor(id: number, color: string): void;
    getSelections(type?: string): Selection[];
    getSelection(id: number): Selection | undefined;
    clearSelections(): void;
    getTimeIdForUnixTime(unixTime: number | undefined): number | undefined;
    addNodeOrdering(name: string, order: number[]): void;
    setNodeOrdering(name: string, order: number[]): void;
    removeNodeOrdering(name: string, order: number[]): void;
    getNodeOrder(name: string): Ordering | undefined;
    nodes(): NodeQuery;
    links(): LinkQuery;
    times(): TimeQuery;
    locations(): LocationQuery;
    nodePairs(): NodePairQuery;
    linksBetween(n1: Node, n2: Node): LinkQuery;
    get(type: string, id: number): BasicElement | undefined;
    getAll(type: string): GraphElementQuery;
    node(id: number): Node | undefined;
    link(id: number): Link | undefined;
    time(id: number): Time | undefined;
    location(id: number): Location | undefined;
    nodePair(id: number): NodePair | undefined;
    getMinGranularity(): number;
    getMaxGranularity(): number;
}
export declare class AttributeArray {
    id: number[];
    get length(): number;
}
export declare class NodeArray extends AttributeArray {
    id: number[];
    label: string[];
    outLinks: ArrayTimeSeries<number>[];
    inLinks: ArrayTimeSeries<number>[];
    links: ArrayTimeSeries<number>[];
    outNeighbors: ArrayTimeSeries<number>[];
    inNeighbors: ArrayTimeSeries<number>[];
    neighbors: ArrayTimeSeries<number>[];
    selections: Selection[][];
    attributes: Record<any, any>[];
    locations: ScalarTimeSeries<number>[];
    filter: boolean[];
    nodeType: string[];
    color: string[];
    shape: string[];
}
export declare class LinkArray extends AttributeArray {
    source: number[];
    target: number[];
    linkType: string[];
    directed: boolean[];
    nodePair: any[];
    presence: number[][];
    weights: ScalarTimeSeries<any>[];
    selections: Selection[][];
    filter: boolean[];
    attributes: Record<any, any>;
}
export declare class NodePairArray extends AttributeArray {
    source: number[];
    target: number[];
    links: number[][];
    selections: Selection[][];
    filter: boolean[];
}
export declare class TimeArray extends AttributeArray {
    id: number[];
    momentTime: Date[];
    label: string[];
    unixTime: number[];
    selections: Selection[][];
    filter: boolean[];
    links: number[][];
}
export declare class LinkTypeArray extends AttributeArray {
    name: string[];
    count: string[];
    color: string[];
    filter: boolean[];
}
export declare class NodeTypeArray extends AttributeArray {
    name: string[];
    count: string[];
    color: string[];
    filter: boolean[];
}
export declare class LocationArray extends AttributeArray {
    id: number[];
    label: string[];
    longitude: number[];
    latitude: number[];
    x: number[];
    y: number[];
    z: number[];
    radius: number[];
}
export declare class NodeType implements LegendElement {
    id: number;
    name: string;
    color: string;
    constructor(id: number, name: string, color: string);
}
export declare class Ordering {
    name: string;
    order: number[];
    constructor(name: string, order: number[]);
}
export declare class Query {
    _elements: number[];
    constructor(elements?: number[]);
    addUnique(element: number): void;
    add(element: number): void;
    addAll(elements: number[]): void;
    addAllUnique(elements: number[]): void;
    /** @returns numbr of elements in this query. Same as size(). */
    get length(): number;
    /** @returns numbr of elements in this query. Same as length getter. */
    size(): number;
    /** @returns all ids in this query. */
    ids(): number[];
    removeDuplicates(): Query;
    generic_intersection(q: Query): Query;
}
export declare class GraphElementQuery extends Query {
    g: DynamicGraph;
    elementType: string;
    constructor(elements: any[], g: DynamicGraph, elementType: string);
    /** @returns a query that contains only the elements matching
     * the filter critera;
     * @param attribute - name of attribute that is used on filter
     * @param filter - function evaluating if the attribute's value is valid.
     */
    generic_filter(filter: (d: any) => boolean): any[];
    /** @returns a query with selected elements, i.e. elements that are in at least
     * one selection.
     */
    generic_selected(): any[];
    /** @returns a query with visible elements.
     */
    generic_visible(): any[];
    /** @returns a query with highighted elements.
     */
    generic_highlighted(): any[];
    /** @returns a query with only the elements present in the specified time step
     * or period.
     */
    generic_presentIn(start: Time, end?: Time): any[];
    /** @returns this query with elements sorted */
    generic_sort(attrName: string, asc?: boolean): GraphElementQuery;
    generic_removeDuplicates(): GraphElementQuery;
}
/** Basic class for every object in networkcube with an ID.
 * A BasicElement is a wrapper to the DynamicGraph and that
 * represents any object, i.e. node, link, node pair, time, location.
 */
export declare class BasicElement {
    _id: number;
    type: string;
    g: DynamicGraph;
    constructor(id: number, type: string, dynamicGraph: DynamicGraph);
    /** @returns the object's id */
    id(): number;
    /** Generic method to return an attribute value for this element
     * @param attr: attribute name on this object.
     * @returns the attribute's value. */
    attr(attr: string): any;
    /** @returns all selections this object is part of. */
    getSelections(): Selection[];
    /** Adds this object to a selection
     * @param selection - the Selection object
     */
    addToSelection(b: Selection): void;
    /** Removes this object from a selection.
     * @param selection - the Selection objects
     */
    removeFromSelection(b: Selection): void;
    inSelection(s: Selection): boolean;
    /** @returns true if this object is selected.
     * @param selection - (optional) if specified returns true if this object
     * is in the passed selection.
     */
    isSelected(selection?: Selection): boolean;
    /** @returns true if this object is highlighted */
    isHighlighted(): boolean;
    /** @returns true if this object is highlighted frozen */
    isFrozen(): boolean;
    /** @returns true if this object is filtered, i.e. removed from display. */
    isFiltered(): boolean;
    /** @returns true if this object is visible. */
    isVisible(): boolean;
    /** @returns true if this object is present in the graph
     * in a specific time or a time period.
     * @param start -  start time. If only this parameter is passed to the
     * function, method returns if this object is present in this time step.
     * @param end - end time. If this parameter is specified, returns if this
     * object is present between start and end.
     */
    presentIn(start: Time, end?: Time): boolean;
}
/** A time series with a scalar value per time step.
 * This class nestes an object that holds information for time
 * steps in the format key->value. I.e. the value for the
 * time step with ID 3 is accessed by this.3   */
export declare class ScalarTimeSeries<T> {
    private serie;
    /** @returns a ScalarTimeSeries for the specified period. */
    period(t1: Time, t2: Time): ScalarTimeSeries<T>;
    /** Sets a value for a specified time point. */
    set(t: Time, element: T): void;
    /** @returns the value for a specified time point. */
    get(t: Time): any;
    size(): number;
    getSerie(): any[];
    /** Returns all values as array.
     * @param removeDuplicates
     * @returns array with values;
     */
    toArray(removeDuplicates?: boolean): T[];
}
/** A time series with an array per time step.
 * This class nestes an object that holds information for time
 * steps in the format key->value. I.e. the value for the
 * time step with ID 3 is accessed by this.3   */
export declare class ArrayTimeSeries<T> {
    serie: any;
    period(t1: Time, t2: Time): ArrayTimeSeries<T>;
    add(t: Time, element: T): void;
    get(t: Time): T[];
    toArray(): T[][];
    toFlatArray(removeDuplicates?: boolean): T[];
}
export declare class TimeQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(t: Time): boolean;
    highlighted(): TimeQuery;
    visible(): TimeQuery;
    selected(): TimeQuery;
    filter(filter: (d: any) => boolean): TimeQuery;
    presentIn(t1: Time, t2: Time): TimeQuery;
    sort(attributeName: string): TimeQuery;
    links(): LinkQuery;
    get(i: number): Time;
    last(): Time;
    toArray(): Time[];
    createAttribute(attrName: string, f: (t: Time) => void): TimeQuery;
    unixTimes(): number[];
    intersection(q: TimeQuery): TimeQuery;
    forEach(f: (t: Time | undefined, i: number) => void): TimeQuery;
}
/**
 * Represents a Time object
 */
export declare class Time extends BasicElement {
    constructor(id: number, dynamicGraph: DynamicGraph);
    /** @returns the Date object associated to this time object. */
    time(): Date;
    moment(): Date;
    label(): string;
    /** @returns the unix time for this time object. */
    unixTime(): number;
    /** @returns a string label for this object. */
    links(): LinkQuery;
    year(): number;
    month(): number;
    getWeek: (date: Date) => string;
    week(): number;
    day(): number;
    hour(): number;
    minute(): number;
    second(): number;
    millisecond(): number;
    format(format: string): string;
}
export declare class LocationQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(l: Location): boolean;
    highlighted(): LocationQuery;
    visible(): LocationQuery;
    selected(): LocationQuery;
    filter(filter: (d: any) => boolean): LocationQuery;
    presentIn(t1: Time, t2: Time): LocationQuery;
    sort(attributeName: string): LocationQuery;
    get(i: number): Location;
    last(): Location;
    toArray(): Location[];
    createAttribute(attrName: string, f: (l: Location) => void): LocationQuery;
    intersection(q: LocationQuery): LocationQuery;
    removeDuplicates(): LocationQuery;
    forEach(f: (l: Location | undefined, i: number) => any): LocationQuery;
}
/**
 * Represents a simple array of numbers that can be used to calculate
 * max, mean, min values etc..
 */
export declare class NumberQuery extends Query {
    clone(): number[];
    min(): number;
    max(): number;
    mean(): number;
    sum(): number;
    toArray(): number[];
    get(index: number): number;
    forEach(f: (n: number, i: number) => any): NumberQuery;
    makeNumbers(elements: number[]): number[];
}
export declare class Location extends BasicElement {
    constructor(id: number, graph: DynamicGraph);
    label(): string;
    longitude(): number;
    latitude(): number;
    x(): number;
    y(): number;
    z(): number;
    radius(): number;
}
export declare class NodePairQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(n: NodePair): boolean;
    highlighted(): NodePairQuery;
    visible(): NodePairQuery;
    selected(): NodePairQuery;
    filter(filter: (d: any) => boolean): NodePairQuery;
    presentIn(t1: Time, t2: Time): NodePairQuery;
    sort(attributeName: string): NodePairQuery;
    get(i: number): NodePair;
    last(): Link;
    toArray(): NodePair[];
    createAttribute(attrName: string, f: (np: NodePair) => void): NodePairQuery;
    intersection(q: NodePairQuery): NodePairQuery;
    removeDuplicates(): NodePairQuery;
    forEach(f: (np: NodePair | undefined, i: number) => any): NodePairQuery;
}
export declare class NodePair extends BasicElement {
    constructor(id: number, graph: DynamicGraph);
    get source(): Node;
    get target(): Node;
    links(): LinkQuery;
    nodeType(): string;
    presentIn(start: Time, end?: Time): boolean;
}
export declare class StringQuery {
    _elements: string[];
    constructor(elements?: string[]);
    contains(element: string): boolean;
    addUnique(element: string): void;
    add(element: string): void;
    addAll(elements: string[]): void;
    addAllUnique(elements: string[]): void;
    get length(): number;
    size(): number;
    toArray(): string[];
    forEach(f: (s: string, i: number) => void): StringQuery;
}
export declare class NodeQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(n: Node): boolean;
    highlighted(): NodeQuery;
    visible(): NodeQuery;
    selected(): NodeQuery;
    filter(filter: (d: any) => boolean): NodeQuery;
    presentIn(t1: Time, t2: Time): NodeQuery;
    sort(attributeName: string, asc?: boolean): NodeQuery;
    label(): StringQuery;
    neighbors(t1?: Time, t2?: Time): NodeQuery;
    links(t1?: Time, t2?: Time): LinkQuery;
    locations(t1?: Time, t2?: Time): LocationQuery;
    nodeTypes(): StringQuery;
    get(i: number): Node;
    last(): Node;
    toArray(): Node[];
    createAttribute(attrName: string, f: (n: Node) => any): NodeQuery;
    intersection(q: NodeQuery): NodeQuery;
    removeDuplicates(): NodeQuery;
    forEach(f: (n: Node | undefined, i: number) => void): NodeQuery;
}
/**
 * Represents a node object
 */
export declare class Node extends BasicElement {
    constructor(id: number, graph: DynamicGraph);
    /** @returns this node's label, specified by the user.
     * If no string value was delivered by the user, returns the ID as string.
     */
    label(): string;
    shape(): string;
    color(): string;
    nodeType(): string;
    /** Returns this nodes neighbors in a NodeQuery. No duplicates.
     * If no parameter is supplied, returns *all* neighbors of this
     * node over all time steps.
     * @param t1 - start time. If only this parameter is specified, returns
     * neighbors in this time step only.
     * @param t2 - end time. If this parameter is specified, returns
     * neighbors between t1 and t2.
     */
    neighbors(t1?: Time, t2?: Time): NodeQuery;
    inNeighbors(t1?: Time, t2?: Time): NodeQuery;
    outNeighbors(t1?: Time, t2?: Time): NodeQuery;
    links(t1?: Time, t2?: Time): LinkQuery;
    inLinks(t1?: Time, t2?: Time): LinkQuery;
    outLinks(t1?: Time, t2?: Time): LinkQuery;
    locations(t1?: Time, t2?: Time): LocationQuery;
    locationSerie(t1?: Time, t2?: Time): ScalarTimeSeries<Location>;
    linksBetween(n: Node): LinkQuery;
}
export declare class LinkQuery extends GraphElementQuery {
    constructor(elements: any[], g: DynamicGraph);
    contains(l: Link): boolean;
    highlighted(): LinkQuery;
    visible(): LinkQuery;
    selected(): LinkQuery;
    filter(filter: (d: any) => boolean): LinkQuery;
    presentIn(t1: Time, t2?: Time): LinkQuery;
    sort(attributeName: string): LinkQuery;
    get(i: number): Link;
    last(): Link;
    toArray(): Link[];
    weights(start?: Time, end?: Time): NumberQuery;
    createAttribute(attrName: string, f: (link: Link) => any): LinkQuery;
    linkTypes(): string[];
    sources(): NodeQuery;
    targets(): NodeQuery;
    intersection(q: LinkQuery): LinkQuery;
    removeDuplicates(): LinkQuery;
    forEach(f: (link: Link | undefined, i: number) => void): LinkQuery;
}
/**
 * Represents a link object on a WindowGraph
 */
export declare class Link extends BasicElement {
    targetNPO: any;
    sourceNPO: any;
    constructor(id: number, graph: DynamicGraph);
    linkType(): string;
    get source(): Node;
    get target(): Node;
    nodePair(): NodePair;
    directed(): boolean;
    other(n: Node): Node;
    /** Returns this link's weights over time as NumberQuery
     * If no time parameter is supplied, returns *all* weights of this
     * link over all time steps.
     * @param t1 - start time. If only this parameter is specified, returns
     * only the value for t1.
     * @param t2 - end time. If this parameter is specified, returns
     * weights between t1 and t2.
     */
    weights(start?: Time, end?: Time): NumberQuery;
    presentIn(start: Time, end?: Time): boolean;
    /** Returns all times in which this link's weight != 0  */
    times(): TimeQuery;
}
export declare class LinkType implements LegendElement {
    id: number;
    name: string;
    color: string;
    constructor(id: number, name: string, color: string);
}
export declare function attributeSort(a: BasicElement, b: BasicElement, attributeName: string, asc?: boolean): number;
export declare class IDCompound {
    nodeIds: number[];
    linkIds: number[];
    timeIds: number[];
    nodePairIds: number[];
    locationIds: number[];
}
export interface LegendElement {
    name: string;
    color: string;
}
/******** MOVED FROM UTILS TO DYNAMICGRAPH *********/
export declare function copyPropsShallow(source: any, target: any): any;
export declare function copyTimeseriesPropsShallow(source: any, target: any): any;
export declare function copyTimeSeries<TElement>(arr: any[], ctorFunc: () => TElement): TElement[];
export declare function compareTypesDeep(a: any, b: any, depth: number): boolean;
export declare function sortNumber(a: number, b: number): number;
export declare function array(value: any, size: number): any[];
export declare function doubleArray(size1: number, size2?: number, value?: any): any[];
