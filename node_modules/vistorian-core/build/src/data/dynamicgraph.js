import { isValidIndex, Selection } from "./dynamicgraphutils";
import { timeFormat } from "d3-time-format";
import { TIME_FORMAT, parseStandardTime, formatStandardTime } from "./dates";
export const GRANULARITY = [
    "millisecond",
    "second",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "year",
    "decade",
    "century",
    "millenium",
]; //, 'decade', 'century', 'millenium'];
// TODO: these levels aren't handled by the relevant functions
export const DGRAPH_SUB = "[*dgraph*]";
export const DGRAPH_SER_VERBOSE_LOGGING = false;
export function dgraphReviver(dgraph, key, value) {
    if (value == DGRAPH_SUB)
        return dgraph;
    else
        return value;
}
export function dgraphReplacer(key, value) {
    // don't write out graph, as this would cause cycles
    if (DGRAPH_SER_VERBOSE_LOGGING) {
        console.log("dgraphReplacer", key, value);
    }
    if (value instanceof DynamicGraph) {
        console.log("dgraphReplacer found a DynamicGraph property", key);
        return DGRAPH_SUB;
    }
    return value;
}
export class DynamicGraph {
    constructor() {
        // BOOKMARK_COLORS: string[] = colorSchemes.schema5;
        this.BOOKMARK_COLORS = this.default_colors;
        this.selectionColor_pointer = 0;
        //data: DataSet;
        this.name = ""; // INIT??
        // data meta data
        this.gran_min = 0; // INIT?
        this.gran_max = Number.MAX_VALUE; // INIT?
        this.minWeight = 10000000;
        this.maxWeight = -10000000;
        this._nodes = [];
        this._links = [];
        this.directed = false;
        this._nodePairs = [];
        this._locations = [];
        // Contains all time objects for this dynamic graph
        this._times = [];
        // linkTypes: LinkType[] = [];
        this.timeObjects = [];
        this.nodeOrders = []; // INIT?
        // Matrix for fast access to node pairs (link)
        this.matrix = []; // fast access to node pairs.
        this.selections = [];
        // node attributes
        this.nodeArrays = new NodeArray();
        // link attributes
        this.linkArrays = new LinkArray();
        // node pair attributes
        this.nodePairArrays = new NodePairArray();
        // time attributes
        this.timeArrays = new TimeArray();
        // array for relation types
        this.linkTypeArrays = new LinkTypeArray();
        // array for node types
        this.nodeTypeArrays = new NodeTypeArray();
        // array for locations
        this.locationArrays = new LocationArray();
        // points to all object arrays. For convenience
        this.attributeArrays = {
            node: this.nodeArrays,
            link: this.linkArrays,
            time: this.timeArrays,
            nodePair: this.nodePairArrays,
            linkType: this.linkTypeArrays,
            nodeType: this.nodeTypeArrays,
            location: this.locationArrays,
        };
        // highlighted objects
        this.highlightArrays = new IDCompound();
        this.highlightFreezeArrays = new IDCompound();
        this.currentSelection_id = 0;
        /* INIT OK?? */
        this.defaultLinkSelection = this.createSelection("link");
        this.defaultNodeSelection = this.createSelection("node");
        // storage keys /////////////////////////////////
        //
        this.gran_min_NAME = "gran_min";
        this.gran_max_NAME = "gran_max_NAME";
        this.directed_NAME = "directed_NAME";
        this.minWeight_NAME = "minWeight_NAME";
        this.maxWeight_NAME = "maxWeight_NAME";
        this.matrix_NAME = "matrix_NAME";
        this.nodeArrays_NAME = "nodeArrays_NAME";
        this.linkArrays_NAME = "linkArrays_NAME";
        this.nodePairArrays_NAME = "nodePairArrays_NAME";
        this.timeArrays_NAME = "timeArrays_NAME";
        this.linkTypeArrays_NAME = "linkTypeArrays_NAME";
        this.nodeTypeArrays_NAME = "nodeTypeArrays_NAME";
        this.locationArrays_NAME = "locationArrays_NAME";
    }
    default_colors(i) {
        const colors = [
            "#3366cc",
            "#dc3912",
            "#ff9900",
            "#109618",
            "#990099",
            "#0099c6",
            "#dd4477",
            "#66aa00",
            "#b82e2e",
            "#316395",
            "#994499",
            "#22aa99",
            "#aaaa11",
            "#6633cc",
            "#e67300",
            "#8b0707",
            "#651067",
            "#329262",
            "#5574a6",
            "#3b3eac",
        ];
        return colors[i % colors.length];
    }
    // ACCESSOR FUNCTIONS
    // universal accesor
    attr(field, id, type) {
        let r;
        try {
            r = this.attributeArrays[type][field][id];
        }
        catch (e) {
            r = undefined;
        }
        return r;
    }
    //
    // end storage keys //////////////////////////////
    // FUNCTIONS
    standardArrayReplacer(key, value) {
        // don't write out graph, as this would cause cycles
        if (value instanceof DynamicGraph) {
            console.log("standardReplacer found a DynamicGraph property", key);
            return DGRAPH_SUB;
        }
        // don't write out selection, because we must preserve it independently
        // from the graph
        else if (key == "selections")
            return undefined;
        return value;
    }
    static timeReviver(k, v, s) {
        if (k == "") {
            return copyPropsShallow(v, new Time(v.id, s));
        }
        else {
            return dgraphReviver(s, k, v);
        }
    }
    static nodeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new NodeArray());
            // case 'nodeType':
            // return copyTimeSeries(v, function() { return new ScalarTimeSeries<string>(); });
            case "outLinks":
            case "inLinks":
            case "links":
                return copyTimeSeries(v, function () {
                    return new ArrayTimeSeries();
                });
            case "outNeighbors":
            case "inNeighbors":
            case "neighbors":
                return copyTimeSeries(v, function () {
                    return new ArrayTimeSeries();
                });
            case "locations":
                return copyTimeSeries(v, function () {
                    return new ScalarTimeSeries();
                });
            default:
                return v;
        }
    }
    static linkArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new LinkArray());
            case "weights":
                return copyTimeSeries(v, function () {
                    return new ScalarTimeSeries();
                });
            default:
                return v;
        }
    }
    static nodePairArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new NodePairArray());
            default:
                return v;
        }
    }
    static timeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new TimeArray());
            case "time":
                return v.map(function (s, i) {
                    return new Date(s);
                });
            default:
                return v;
        }
    }
    static linkTypeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new LinkTypeArray());
            default:
                return v;
        }
    }
    static nodeTypeArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new NodeTypeArray());
            default:
                return v;
        }
    }
    static locationArrayReviver(k, v, s) {
        switch (k) {
            case "":
                return copyPropsShallow(v, new LocationArray());
            default:
                return v;
        }
    }
    loadDynamicGraph(dataMgr, dataSetName) {
        this.clearSelections();
        this.name = dataSetName;
        // CACHEGRAPH : load from storage the entire state of the graph
        const gran_min_storage = dataMgr.getFromStorage(this.name, this.gran_min_NAME);
        if (gran_min_storage != undefined)
            this.gran_min = gran_min_storage;
        const gran_max_storage = dataMgr.getFromStorage(this.name, this.gran_max_NAME);
        if (gran_max_storage != undefined)
            this.gran_max = gran_max_storage;
        const directed_storage = dataMgr.getFromStorage(this.name, this.directed_NAME);
        if (directed_storage != undefined)
            this.directed = directed_storage;
        const minWeight_storage = dataMgr.getFromStorage(this.name, this.minWeight_NAME);
        if (minWeight_storage != undefined)
            this.minWeight = minWeight_storage;
        const maxWeight_storage = dataMgr.getFromStorage(this.name, this.maxWeight_NAME);
        if (maxWeight_storage != undefined)
            this.maxWeight = maxWeight_storage;
        const matrix_storage = dataMgr.getFromStorage(this.name, this.matrix_NAME);
        if (matrix_storage != undefined)
            this.matrix = matrix_storage;
        const nodeArrays_storage = dataMgr.getFromStorage(this.name, this.nodeArrays_NAME, DynamicGraph.nodeArrayReviver);
        if (nodeArrays_storage != undefined)
            this.nodeArrays = nodeArrays_storage;
        const linkArrays_storage = dataMgr.getFromStorage(this.name, this.linkArrays_NAME, DynamicGraph.linkArrayReviver);
        if (linkArrays_storage != undefined)
            this.linkArrays = linkArrays_storage;
        const nodePairArrays_storage = dataMgr.getFromStorage(this.name, this.nodePairArrays_NAME, DynamicGraph.nodePairArrayReviver);
        if (nodePairArrays_storage != undefined)
            this.nodePairArrays = nodePairArrays_storage;
        const timeArrays_storage = dataMgr.getFromStorage(this.name, this.timeArrays_NAME, DynamicGraph.timeArrayReviver);
        if (timeArrays_storage != undefined)
            this.timeArrays = timeArrays_storage;
        if (!("timeArrays" in this) || !this.timeArrays) {
            console.log("No timeArrays");
            this.timeArrays = new TimeArray();
        }
        else if ("momentTime" in this.timeArrays &&
            "unixTime" in this.timeArrays) {
            const ta = this.timeArrays["momentTime"];
            for (let i = 0; i < ta.length; i++) {
                ta[i] = new Date(this.timeArrays["unixTime"][i]);
            }
        }
        else if ("unixTime" in this.timeArrays) {
            /* I DON'T KNOW WHY timeArrays IS never */
            console.log("No time in timeArrays");
            this.timeArrays["momentTime"] = this.timeArrays["unixTime"].map(new Date());
        }
        else {
            console.log("No time or unixTime in timeArrays");
            this.timeArrays["momentTime"] = [];
        }
        const linkTypeArrays_storage = dataMgr.getFromStorage(this.name, this.linkTypeArrays_NAME, DynamicGraph.linkTypeArrayReviver);
        if (linkTypeArrays_storage != undefined)
            this.linkTypeArrays = linkTypeArrays_storage;
        const nodeTypeArrays_storage = dataMgr.getFromStorage(this.name, this.nodeTypeArrays_NAME, DynamicGraph.nodeTypeArrayReviver);
        if (nodeTypeArrays_storage != undefined)
            this.nodeTypeArrays = nodeTypeArrays_storage;
        const locationArrays_storage = dataMgr.getFromStorage(this.name, this.locationArrays_NAME, DynamicGraph.locationArrayReviver);
        if (locationArrays_storage != undefined)
            this.locationArrays = locationArrays_storage;
        // points to all object arrays. For convenience
        this.attributeArrays = {
            node: this.nodeArrays,
            link: this.linkArrays,
            time: this.timeArrays,
            nodePair: this.nodePairArrays,
            linkType: this.linkTypeArrays,
            nodeType: this.nodeTypeArrays,
            location: this.locationArrays,
        };
        // rather than persist all of the state of windowGraph
        // as well, we simply reinitialize from our persisted state.
        // perhaps we need to serialize this as well.
        // inits the WindowGraph for this dynamic graph, i.e.
        // the all-aggregated graph.
        this.createGraphObjects(true, true);
        // init the selections which are currently null
        // this.nodeArrays.selections=[];
        // this.nodeArrays.selections.push([]);
        // this.timeArrays.selections=[];
        // this.timeArrays.selections.push([]);
        // this.linkArrays.selections=[];
        // this.linkArrays.selections.push([]);
        // this.nodePairArrays.selections=[];
        // this.nodePairArrays.selections.push([]);
        this.createSelections(true);
    }
    saveDynamicGraph(dataMgr) {
        // CACHEGRAPH : persist the entire state of the dynamic graph
        dataMgr.saveToStorage(this.name, this.gran_min_NAME, this.gran_min);
        dataMgr.saveToStorage(this.name, this.gran_max_NAME, this.gran_max);
        dataMgr.saveToStorage(this.name, this.directed_NAME, this.directed);
        dataMgr.saveToStorage(this.name, this.minWeight_NAME, this.minWeight);
        dataMgr.saveToStorage(this.name, this.maxWeight_NAME, this.maxWeight);
        dataMgr.saveToStorage(this.name, this.matrix_NAME, this.matrix);
        dataMgr.saveToStorage(this.name, this.nodeArrays_NAME, this.nodeArrays, this.standardArrayReplacer);
        // when we tried to persist the entire linkArrays, javascript threw an
        // exception, so for now we will simply try to save out the parts.
        dataMgr.saveToStorage(this.name, this.linkArrays_NAME, this.linkArrays, this.standardArrayReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"source", this.linkArrays.source, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"target", this.linkArrays.target, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"linkType", this.linkArrays.linkType, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"directed", this.linkArrays.directed, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"nodePair", this.linkArrays.nodePair, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"presence", this.linkArrays.presence, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"weights", this.linkArrays.weights, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"filter", this.linkArrays.filter, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"attributes", this.linkArrays.attributes, this.standardReplacer);
        dataMgr.saveToStorage(this.name, this.nodePairArrays_NAME, this.nodePairArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.timeArrays_NAME, this.timeArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.linkTypeArrays_NAME, this.linkTypeArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.nodeTypeArrays_NAME, this.nodeTypeArrays, this.standardArrayReplacer);
        dataMgr.saveToStorage(this.name, this.locationArrays_NAME, this.locationArrays, this.standardArrayReplacer);
    }
    // Removes this graph from the cache.
    delete(dataMgr) {
        dataMgr.removeFromStorage(this.name, this.gran_min_NAME);
        dataMgr.removeFromStorage(this.name, this.gran_max_NAME);
        dataMgr.removeFromStorage(this.name, this.directed_NAME);
        dataMgr.removeFromStorage(this.name, this.minWeight_NAME);
        dataMgr.removeFromStorage(this.name, this.maxWeight_NAME);
        dataMgr.removeFromStorage(this.name, this.matrix_NAME);
        dataMgr.removeFromStorage(this.name, this.nodeArrays_NAME);
        // when we tried to persist the entire linkArrays, javascript threw an
        // exception, so for now we will simply try to save out the parts.
        dataMgr.removeFromStorage(this.name, this.linkArrays_NAME);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"source", this.linkArrays.source, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"target", this.linkArrays.target, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"linkType", this.linkArrays.linkType, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"directed", this.linkArrays.directed, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"nodePair", this.linkArrays.nodePair, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"presence", this.linkArrays.presence, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"weights", this.linkArrays.weights, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"filter", this.linkArrays.filter, this.standardReplacer);
        // dataMgr.saveToStorage(this.name, this.linkArrays_NAME+"attributes", this.linkArrays.attributes, this.standardReplacer);
        dataMgr.removeFromStorage(this.name, this.nodePairArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.timeArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.linkTypeArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.nodeTypeArrays_NAME);
        dataMgr.removeFromStorage(this.name, this.locationArrays_NAME);
    }
    debugCompareTo(other) {
        let result = true;
        if (this.name != other.name) {
            console.log("name different");
            result = false;
        }
        // CACHEGRAPH compare every aspect of this one to the other one
        if (this.gran_min != other.gran_min) {
            console.log("gran_min different", this.gran_min, other.gran_min);
            result = false;
        }
        if (this.gran_max != other.gran_max) {
            console.log("gran_max different", this.gran_max, other.gran_max);
            result = false;
        }
        if (this.directed != other.directed) {
            console.log("directed different", this.directed, other.directed);
            result = false;
        }
        if (this._nodes.length != other._nodes.length ||
            !compareTypesDeep(this._nodes, other._nodes, 2)) {
            console.log("nodes different");
            result = false;
        }
        if (this._links.length != other._links.length ||
            !compareTypesDeep(this._links, other._links, 2)) {
            console.log("links different");
            result = false;
        }
        if (this._nodePairs.length != other._nodePairs.length ||
            !compareTypesDeep(this._nodePairs, other._nodePairs, 2)) {
            console.log("nodePairs different");
            result = false;
        }
        if (this._locations.length != other._locations.length ||
            !compareTypesDeep(this._locations, other._locations, 2)) {
            console.log("locations different");
            result = false;
        }
        if (this._times.length != other._times.length ||
            !compareTypesDeep(this._times, other._times, 2)) {
            console.log("times different");
            result = false;
        }
        if ((this.nodeOrders && this.nodeOrders.length != other.nodeOrders.length) ||
            !compareTypesDeep(this.nodeOrders, other.nodeOrders, 2)) {
            console.log("nodeOrders different", this.nodeOrders, other.nodeOrders);
            result = false;
        }
        if (this.matrix.length != other.matrix.length ||
            !compareTypesDeep(this.matrix, other.matrix, 2)) {
            console.log("matrix different", this.matrix, other.matrix);
            result = false;
        }
        if (this.nodeArrays.length != other.nodeArrays.length ||
            !compareTypesDeep(this.nodeArrays, other.nodeArrays, 2)) {
            console.log("nodeArrays different", this.nodeArrays, other.nodeArrays);
            result = false;
        }
        if (this.linkArrays.length != other.linkArrays.length ||
            !compareTypesDeep(this.linkArrays, other.linkArrays, 2)) {
            console.log("linkArrays different", this.linkArrays, other.linkArrays);
            result = false;
        }
        if (this.nodePairArrays.length != other.nodePairArrays.length ||
            !compareTypesDeep(this.nodePairArrays, other.nodePairArrays, 2)) {
            console.log("nodePairArrays different", this.nodePairArrays, other.nodePairArrays);
            result = false;
        }
        if (this.timeArrays.length != other.timeArrays.length ||
            !compareTypesDeep(this.timeArrays, other.timeArrays, 2)) {
            console.log("timeArrays different", this.timeArrays, other.timeArrays);
            result = false;
        }
        if (this.linkTypeArrays.length != other.linkTypeArrays.length ||
            !compareTypesDeep(this.linkTypeArrays, other.linkTypeArrays, 2)) {
            console.log("linkTypeArrays different", this.linkTypeArrays, other.linkTypeArrays);
            result = false;
        }
        if (this.nodeTypeArrays.length != other.nodeTypeArrays.length ||
            !compareTypesDeep(this.nodeTypeArrays, other.nodeTypeArrays, 2)) {
            console.log("nodeTypeArrays different", this.nodeTypeArrays, other.nodeTypeArrays);
            result = false;
        }
        if (this.locationArrays.length != other.locationArrays.length ||
            !compareTypesDeep(this.locationArrays, other.locationArrays, 2)) {
            console.log("locationArrays different", this.locationArrays, other.locationArrays);
            result = false;
        }
        if (this.defaultLinkSelection.elementIds.length !=
            other.defaultLinkSelection.elementIds.length ||
            !compareTypesDeep(this.defaultLinkSelection, other.defaultLinkSelection, 2)) {
            console.log("defaultLinkSelection different", this.defaultLinkSelection, other.defaultLinkSelection);
            result = false;
        }
        if (this.defaultNodeSelection.elementIds.length !=
            other.defaultNodeSelection.elementIds.length ||
            !compareTypesDeep(this.defaultNodeSelection, other.defaultNodeSelection, 2)) {
            console.log("defaultNodeSelection different", this.defaultNodeSelection, other.defaultNodeSelection);
            result = false;
        }
        if (this.selections.length != other.selections.length ||
            !compareTypesDeep(this.selections, other.selections, 2)) {
            console.log("selections different", this.selections, other.selections);
            result = false;
        }
        return result;
    }
    // creates this graph and fills node, link and time arrays from
    // data tables.
    initDynamicGraph(data) {
        var _a, _b, _c, _d, _e;
        this.clearSelections();
        console.log("[dynamicgraph.ts] Create dynamic graph for ", data.name, data);
        //this.data = data;s
        this.name = data.name;
        this.directed = data.directed;
        // fill node, link arrays and time
        // CREATE TIME OBJECT for all events
        this.gran_min = 0;
        this.gran_max = 0;
        let timeLabel;
        const unixTimes = [];
        let unixTime;
        if (isValidIndex(data.linkSchema.time)) {
            // get unix times for all times
            console.log("GEtting unix times for all times - linktable");
            console.log(data.linkTable);
            for (let i = 0; i < data.linkTable.length; i++) {
                timeLabel = data.linkTable[i][data.linkSchema.time];
                console.log(data.linkTable[i]);
                unixTime = (_a = parseStandardTime(timeLabel)) === null || _a === void 0 ? void 0 : _a.getTime();
                if (unixTime == undefined)
                    continue;
                if (unixTimes.indexOf(unixTime) == -1) {
                    unixTimes.push(unixTime);
                }
            }
            // obtain granularity
            unixTimes.sort(sortNumber);
            let diff = 99999999999999;
            for (let i = 0; i < unixTimes.length - 2; i++) {
                diff = Math.min(diff, unixTimes[i + 1] - unixTimes[i]);
            }
            if (diff >= 1000)
                this.gran_min = 1;
            if (diff >= 1000 * 60)
                this.gran_min = 2;
            if (diff >= 1000 * 60 * 60)
                this.gran_min = 3;
            if (diff >= 1000 * 60 * 60 * 24)
                this.gran_min = 4;
            if (diff >= 1000 * 60 * 60 * 24 * 7)
                this.gran_min = 5;
            if (diff >= 1000 * 60 * 60 * 24 * 30)
                this.gran_min = 6;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                this.gran_min = 7;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                this.gran_min = 8;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                this.gran_min = 9;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                this.gran_min = 10;
            diff = unixTimes[unixTimes.length - 1] - unixTimes[0];
            this.gran_max = 0;
            if (diff >= 1000)
                this.gran_max = 1;
            if (diff >= 1000 * 60)
                this.gran_max = 2;
            if (diff >= 1000 * 60 * 60)
                this.gran_max = 3;
            if (diff >= 1000 * 60 * 60 * 24)
                this.gran_max = 4;
            if (diff >= 1000 * 60 * 60 * 24 * 7)
                this.gran_max = 5;
            if (diff >= 1000 * 60 * 60 * 24 * 30)
                this.gran_max = 6;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                this.gran_max = 7;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                this.gran_max = 8;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                this.gran_max = 9;
            if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                this.gran_max = 10;
            console.log("[Dynamic Graph] Minimal granularity", GRANULARITY[this.gran_min]);
            console.log("[Dynamic Graph] Maximal granularity", GRANULARITY[this.gran_max]);
            // create one time object for every time point of gran_min, between start and end time.
            // [bb] deprecated
            // var start = moment(unixTimes[0] + '', 'x').startOf(GRANULARITY[this.gran_min]);
            // var end = moment(unixTimes[unixTimes.length - 1] + '', 'x').startOf(GRANULARITY[this.gran_min]);
            // var numTimes = Math.ceil(Math.abs(start.diff(end, GRANULARITY[this.gran_min] + 's')));
            // var curr_t = start;
            // this._times = [];
            for (let i = 0; i < unixTimes.length; i++) {
                this.timeArrays.id.push(i);
                this.timeArrays.momentTime.push(new Date(unixTimes[i]));
                this.timeArrays.label.push(formatStandardTime(this.timeArrays.momentTime[i]));
                this.timeArrays.unixTime.push(unixTimes[i]);
                this.timeArrays.selections.push([]);
                this.timeArrays.filter.push(false);
                this.timeArrays.links.push([]);
                // create time objects
                this._times.push(new Time(i, this));
                // curr_t = start.add(1, GRANULARITY[this.gran_min] + 's');
            }
            // Now, all existing times with events and potentially
            // attributes associated, have been created.
            // Below, we create a simple array of moment.moments
            // for any possible time unit for every aggregation level.
            // In fact, those structures are created on-demand, i.e.
            // the first time they are needed.
            // Here, we only create the meta-structure
            for (let g = 0; g <= GRANULARITY.length; g++) {
                this.timeObjects.push([]); // AQUIIIII
            }
        }
        // if no valid have been found:
        if (this.timeArrays.length == 0) {
            // null time object that represents one time step for the entire graph, i.e. a static graph
            this.timeArrays.id.push(0);
            this.timeArrays.momentTime.push(new Date(0));
            this.timeArrays.unixTime.push(0);
            this.timeArrays.selections.push([]);
            this.timeArrays.filter.push(false);
            this.timeArrays.links.push([]);
            this._times.push(new Time(0, this));
        }
        // from here on, there is at least one time object present.
        // CREATE LOCATIONS
        // if there is a location table, then there needs to be locationSchema
        console.assert(!data.locationTable || isValidIndex(data.locationSchema.id));
        if (data.locationTable) {
            for (let i = 0; i < data.locationTable.length; i++) {
                this.locationArrays.id.push(data.locationTable[i][data.locationSchema.id]);
                this.locationArrays.label.push(data.locationTable[i][data.locationSchema.label]);
                this.locationArrays.longitude.push(data.locationTable[i][data.locationSchema.longitude]);
                this.locationArrays.latitude.push(data.locationTable[i][data.locationSchema.latitude]);
                this.locationArrays.x.push(data.locationTable[i][data.locationSchema.x]);
                this.locationArrays.y.push(data.locationTable[i][data.locationSchema.y]);
                this.locationArrays.z.push(data.locationTable[i][data.locationSchema.z]);
                this.locationArrays.radius.push(data.locationTable[i][data.locationSchema.radius]);
            }
        }
        if ("id" in this.locationArrays)
            console.log("locations", this.locationArrays.id.length);
        // CREATE NODES
        let row;
        let nodeId_data; // node id in data set
        let nodeId_table; // node id in table
        let time;
        console.assert(data.nodeTable.length == 0 || isValidIndex(data.nodeSchema.id), "either there is no nodeTable data, or we have a schema for the nodetable");
        let typeName;
        let typeId;
        const nodeUserProperties = [];
        // Get user-properties on links, if exist
        for (const prop in data.nodeSchema) {
            if (Object.prototype.hasOwnProperty.call(data.nodeSchema, prop) &&
                prop != "id" &&
                prop != "label" &&
                prop != "time" &&
                prop != "name" &&
                prop != "nodeType" &&
                prop != "location" &&
                prop != "constructor") {
                nodeUserProperties.push(prop);
                // create property
                this.nodeArrays[prop] = [];
            }
        }
        for (let i = 0; i < data.nodeTable.length; i++) {
            row = data.nodeTable[i];
            // check if id already exists
            nodeId_data = row[data.nodeSchema.id];
            nodeId_table = this.nodeArrays.id.indexOf(nodeId_data);
            if (nodeId_table == -1) {
                nodeId_table = this.nodeArrays.id.length;
                this.nodeArrays.id.push(nodeId_data);
                this.nodeArrays.nodeType.push("");
                this.nodeArrays.outLinks.push(new ArrayTimeSeries());
                this.nodeArrays.inLinks.push(new ArrayTimeSeries());
                this.nodeArrays.links.push(new ArrayTimeSeries()); // both, in and out
                this.nodeArrays.outNeighbors.push(new ArrayTimeSeries());
                this.nodeArrays.inNeighbors.push(new ArrayTimeSeries());
                this.nodeArrays.neighbors.push(new ArrayTimeSeries());
                this.nodeArrays.selections.push([]);
                this.nodeArrays.filter.push(false);
                this.nodeArrays.locations.push(new ScalarTimeSeries());
                this.nodeArrays.attributes.push(new Object());
                this.nodeArrays.color.push("");
                this.nodeArrays.shape.push("");
                if (isValidIndex(data.nodeSchema.label)) {
                    this.nodeArrays.label.push(row[data.nodeSchema.label]);
                }
                else {
                    this.nodeArrays.label.push(row[data.nodeSchema.id]);
                }
            }
            // get time
            // if (isValidIndex(data.nodeSchema.time)) {
            if (isValidIndex(data.nodeSchema.time)) {
                timeLabel = row[data.nodeSchema.time];
                console.log("params");
                console.log(timeLabel);
                console.log(TIME_FORMAT);
                console.log((_b = parseStandardTime(timeLabel)) === null || _b === void 0 ? void 0 : _b.toUTCString());
                console.log((_c = parseStandardTime(timeLabel)) === null || _c === void 0 ? void 0 : _c.getTime());
                const timeIdForUnixTime = this.getTimeIdForUnixTime((_d = parseStandardTime(timeLabel)) === null || _d === void 0 ? void 0 : _d.getTime());
                if (timeLabel == undefined || timeIdForUnixTime == undefined) {
                    //} || timeStamp.indexOf('null')) {
                    time = this._times[0];
                }
                else {
                    time = this._times[timeIdForUnixTime];
                }
            }
            else {
                time = this._times[0];
            }
            if (time == undefined)
                time = this._times[0];
            // check locations
            if (isValidIndex(data.nodeSchema.location)) {
                const locId = row[data.nodeSchema.location];
                if (locId == null || locId == undefined)
                    continue;
                this.nodeArrays.locations[nodeId_data].set(time, locId);
            }
            // check shapes
            if (isValidIndex(data.nodeSchema.shape)) {
                const shape = row[data.nodeSchema.shape];
                this.nodeArrays.shape.push(shape);
            }
            // gather node type
            if (isValidIndex(data.nodeSchema.nodeType)) {
                typeName = data.nodeTable[i][data.nodeSchema.nodeType];
                typeId = this.nodeTypeArrays.name.indexOf(typeName);
                if (typeId < 0) {
                    typeId = this.nodeTypeArrays.length;
                    this.nodeTypeArrays.id.push(typeId);
                    this.nodeTypeArrays.name.push(typeName);
                }
                this.nodeArrays.nodeType[nodeId_table] = typeName;
                data.nodeTable[i][data.nodeSchema.nodeType] = typeId;
            }
            // gather user-properties:
            for (let p = 0; p < nodeUserProperties.length; p++) {
                const prop = nodeUserProperties[p];
                this.nodeArrays[prop].push(row[data.nodeSchema[prop]]);
            }
            // see if temporal information is available
            // if(data.nodeSchema.time && data.nodeSchema.time > -1){
            //     for(var field in data.nodeSchema){
            //         if (field != undefined
            //             && data.nodeSchema.hasOwnProperty(field)
            //             && data.Â©nodeSchema[field] > -1
            //             && field != 'label'
            //             && field != 'time'
            //             && field != 'locations'
            //             && field != 'id'
            //             ){
            //                 if(this.nodeArrays.attributes[nodeId_table][field] == undefined){
            //                     this.nodeArrays.attributes[nodeId_table][field] = new ScalarTimeSeries();
            //                 }
            //                 timeLabel = data.nodeTable[i][data.nodeSchema.time];
            //                 if(timeLabel == undefined)
            //                     continue;
            //                 timeStamp = parseInt(moment(timeLabel, networkcube.TIME_FORMAT).format('x'));
            //                 time = this.times[this.getTimeIdForTimeStamp(timeStamp)];
            //                 this.nodeArrays[field][nodeId_table].set(time, row[data.nodeSchema[field]]);
            //             // //in case of locations:
            //             // if(field == 'location'){
            //             //     if(typeof row[data.nodeSchema[field]] == 'number'){
            //             //         id_loc = row[data.nodeSchema[field]];
            //             //     }
            //             // }
            //          }
            //     }
            // }else{
            //     // no time information available on nodes
            //     for(var field in data.nodeSchema){
            //         if (field != undefined
            //             && data.nodeSchema.hasOwnProperty(field)
            //             && data.nodeSchema[field] > -1
            //             && field != 'label'
            //             && field != 'time'
            //             && field != 'id'
            //             && field != 'locations'
            //             )
            //         {
            //             // check for non temporal information
            //             if(this.nodeArrays.attributes[nodeId_table][field] == undefined){
            //                 this.nodeArrays.attributes[nodeId_table][field] = new ScalarTimeSeries();
            //             }
            //             // eternal attributes are assigned no time.
            //             this.nodeArrays[field][nodeId_table].set(undefined, row[data.nodeSchema[field]]);
            //         }
            //     }
            // }
        }
        // create matrix and initialize with -1, i.e. nodes are not connected.
        if ("id" in this.nodeArrays) {
            for (let i = 0; i < this.nodeArrays.id.length; i++) {
                this.matrix.push(array(undefined, this.nodeArrays.id.length));
            }
        }
        // CREATE LINKS
        let s, t;
        let timeId;
        let nodePairId;
        let linkId;
        const linkUserProperties = [];
        // Get user-properties on links, if exist
        for (const prop in data.linkSchema) {
            if (Object.prototype.hasOwnProperty.call(data.linkSchema, prop) &&
                prop != "id" &&
                prop != "linkType" &&
                prop != "time" &&
                prop != "name" &&
                prop != "source" &&
                prop != "target" &&
                prop != "weight" &&
                prop != "directed") {
                linkUserProperties.push(prop);
                // create property
                this.linkArrays[prop] = [];
            }
        }
        console.log("linkUserProperties", linkUserProperties);
        console.assert(data.linkTable.length == 0 ||
            (isValidIndex(data.linkSchema.id) &&
                isValidIndex(data.linkSchema.source) &&
                isValidIndex(data.linkSchema.target)), "either there are no links, or the linkschema is defined");
        for (let i = 0; i < data.linkTable.length; i++) {
            row = data.linkTable[i];
            linkId = row[data.linkSchema.id];
            this.linkArrays.directed.push(false); // this is default and can be overwritten in the following.
            // check if linkId, i.e. link exists
            if (this.linkArrays.id.indexOf(linkId) == -1) {
                // init new link
                this.linkArrays.id[linkId] = linkId;
                this.linkArrays.source[linkId] = row[data.linkSchema.source];
                this.linkArrays.target[linkId] = row[data.linkSchema.target];
                this.linkArrays.linkType[linkId] = row[data.linkSchema.linkType];
                this.linkArrays.directed[linkId] = row[data.linkSchema.directed];
                this.linkArrays.weights[linkId] = new ScalarTimeSeries();
                this.linkArrays.presence[linkId] = [];
                this.linkArrays.selections.push([]);
                this.linkArrays.nodePair.push(undefined);
                this.linkArrays.filter.push(false);
            }
            // set time information
            if (isValidIndex(data.linkSchema.time)) {
                timeLabel = data.linkTable[i][data.linkSchema.time];
                unixTime = (_e = parseStandardTime(timeLabel)) === null || _e === void 0 ? void 0 : _e.getTime();
                const timeIdForUnixTime = unixTime
                    ? this.getTimeIdForUnixTime(unixTime)
                    : undefined;
                if (timeIdForUnixTime != undefined) {
                    timeId = timeIdForUnixTime;
                }
                else {
                    timeId = 0;
                }
            }
            else {
                timeId = 0;
            }
            time = this._times[timeId];
            this.linkArrays.presence[linkId].push(timeId);
            // set weight if applies
            if (isValidIndex(data.linkSchema.weight) &&
                data.linkTable[i][data.linkSchema.weight] != undefined) {
                this.linkArrays.weights[linkId].set(time, data.linkTable[i][data.linkSchema.weight]);
                this.minWeight = Math.min(this.minWeight, data.linkTable[i][data.linkSchema.weight]);
                this.maxWeight = Math.max(this.maxWeight, data.linkTable[i][data.linkSchema.weight]);
            }
            else {
                // set one = presence
                this.minWeight = 0;
                this.maxWeight = 1;
                this.linkArrays.weights[linkId].set(time, 1);
            }
            // add graph specific information
            s = this.nodeArrays.id.indexOf(row[data.linkSchema.source]);
            t = this.nodeArrays.id.indexOf(row[data.linkSchema.target]);
            this.nodeArrays.neighbors[s].add(time, t);
            this.nodeArrays.neighbors[t].add(time, s);
            this.nodeArrays.links[s].add(time, linkId);
            this.nodeArrays.links[t].add(time, linkId);
            // for directed links, fill the in/out arrays
            if (this.linkArrays.directed[i]) {
                this.nodeArrays.outNeighbors[s].add(time, t);
                this.nodeArrays.inNeighbors[t].add(time, s);
                this.nodeArrays.outLinks[s].add(time, linkId);
                this.nodeArrays.inLinks[t].add(time, linkId);
            }
            //link pairs
            // a node pair is stored in a matrix structure for easy access.
            // For every direction (s,t) and (t,s), an individual link pair
            // exists. If an underlying link is undirected, it is referenced
            // in both node pairs.
            nodePairId = this.matrix[s][t];
            if (!isValidIndex(nodePairId)) {
                nodePairId = this.nodePairArrays.length;
                this.matrix[s][t] = nodePairId;
                this.nodePairArrays.id.push(nodePairId);
                this.nodePairArrays.source.push(s);
                this.nodePairArrays.target.push(t);
                this.nodePairArrays.links.push([]);
                this.nodePairArrays.selections.push([]);
                this.nodePairArrays.filter.push(false);
            }
            // add link only, if not already exist
            if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
                this.nodePairArrays.links[nodePairId].push(linkId);
                this.linkArrays.nodePair[linkId] = nodePairId;
            }
            //May affect matrix view, but breaks nodelink directionality
            // if (this.linkArrays.directed[i]) {
            //     nodePairId = this.matrix[t][s];
            //     if (!nodePairId) {
            //         nodePairId = this.nodePairArrays.id.length;
            //         this.matrix[t][s] = nodePairId;
            //         this.nodePairArrays.id.push(nodePairId);
            //         this.nodePairArrays.source.push(t);
            //         this.nodePairArrays.target.push(s);
            //         this.nodePairArrays.links.push(doubleArray(this._times.length));
            //     }
            //     // add link only, if not already exist
            //     if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
            //         this.nodePairArrays.links[nodePairId].push(linkId);
            //         this.linkArrays.nodePair[linkId] = nodePairId;
            //     }
            // }
            // gather link types
            if (isValidIndex(data.linkSchema.linkType)) {
                typeName = data.linkTable[i][data.linkSchema.linkType];
                typeId = this.linkTypeArrays.name.indexOf(typeName);
                if (typeId < 0) {
                    typeId = this.linkTypeArrays.length;
                    this.linkTypeArrays.id.push(typeId);
                    this.linkTypeArrays.name.push(typeName);
                }
                data.linkTable[i][data.linkSchema.linkType] = typeId;
            }
            // gather user-properties:
            for (let p = 0; p < linkUserProperties.length; p++) {
                const prop = linkUserProperties[p];
                this.linkArrays[prop].push(row[data.linkSchema[prop]]);
            }
        }
        // For every time, store a pointer to all its links:
        // var allLinks = links().toArray();
        // var allTimes = this.g.times().toArray();
        for (let i = 0; i < this.linkArrays.length; i++) {
            for (let j = 0; j < this.timeArrays.length; j++) {
                if (this.linkArrays.weights[i]) {
                    if (Object.prototype.hasOwnProperty.call(this.linkArrays.weights[i].toArray(), this.timeArrays.id[j].toString())) {
                        this.timeArrays.links[j].push(this.linkArrays.id[i]);
                    }
                }
            }
        }
        //Build a color mapping
        const colorSet = new Set([
            "#e4549b",
            "#a33a36",
            "#bd6221",
            "#dfba47",
            "#b5b867",
            "#479b7f",
            "#335b8e",
            "#78387d",
        ]);
        const colorMappings = {};
        this.nodeArrays.color.forEach(function (color) {
            if (!colorMappings[color]) {
                const colorSetAsArray = Array.from(colorSet);
                const generatedColor = colorSetAsArray[Math.floor(Math.random() * colorSetAsArray.length)];
                colorMappings[color] = generatedColor;
                colorSet.delete(generatedColor);
            }
        });
        //Add color values to nodeArray colors
        /*
            for(let i=0; i<this.nodeArrays.color.length; i++) {
                this.nodeArrays.color[i] = this.nodeArrays.color[i], colorMappings[this.nodeArrays.color[i]];
            }
            */
        //Build a shape mapping
        const shapeSet = new Set(["cross", "diamond", "square", "triangle"]);
        const shapeMappings = {};
        this.nodeArrays.shape.forEach(function (shape) {
            if (!shapeMappings[shape]) {
                const shapeSetAsArray = Array.from(shapeSet);
                const generatedShape = shapeSetAsArray[Math.floor(Math.random() * shapeSetAsArray.length)];
                shapeMappings[shape] = generatedShape;
                shapeSet.delete(generatedShape);
            }
        });
        //Add shapes to nodeArray shapes
        /*
            for(let i=0; i<this.nodeArrays.shape.length; i++) {
                this.nodeArrays.shape[i] = this.nodeArrays.shape[i], shapeMappings[this.nodeArrays.shape[i]];
            }
            */
        // create color map for link types
        console.log("[Dynamic Graph] Dynamic Graph created: ", this.nodeArrays.length);
        console.log("[Dynamic Graph]    - Nodes: ", this.nodeArrays.length);
        console.log("[Dynamic Graph]    - Edges: ", this.linkArrays.length);
        console.log("[Dynamic Graph]    - Times: ", this.timeArrays.length);
        console.log("[Dynamic Graph]    - Link types: ", this.linkTypeArrays.length);
        console.log("[Dynamic Graph]    - Node Pairs: ", this.nodePairArrays.length);
        console.log('>>>this.nodeArrays["neighbors"][0]', this.nodeArrays["neighbors"][0]);
        // inits the WindowGraph for this dynamic graph, i.e.
        // the all-aggregated graph.
        this.createGraphObjects(true, true); //false, false);
        this.createSelections(false);
    }
    createSelections(shouldCreateArrays) {
        // CREATE SELECTIONS
        if (shouldCreateArrays) {
            if (!("nodeArrays" in this && this.nodeArrays)) {
                this.nodeArrays = new NodeArray();
                this.linkArrays = new LinkArray();
                this.timeArrays = new TimeArray();
                this.nodePairArrays = new NodePairArray();
            }
            this.nodeArrays.selections = new Array(this.nodeArrays.length);
            for (let i = 0; i < this.nodeArrays.selections.length; i++) {
                this.nodeArrays.selections[i] = [];
            }
            this.linkArrays.selections = new Array(this.linkArrays.length);
            for (let i = 0; i < this.linkArrays.selections.length; i++) {
                this.linkArrays.selections[i] = [];
            }
            this.timeArrays.selections = new Array(this.timeArrays.length);
            for (let i = 0; i < this.timeArrays.selections.length; i++) {
                this.timeArrays.selections[i] = [];
            }
            this.nodePairArrays.selections = new Array(this.nodePairArrays.length);
            for (let i = 0; i < this.nodePairArrays.selections.length; i++) {
                this.nodePairArrays.selections[i] = [];
            }
        }
        // create default selections for each type
        this.defaultNodeSelection = this.createSelection("node");
        this.defaultNodeSelection.name = "Unselected";
        for (let i = 0; i < this._nodes.length; i++) {
            this.defaultNodeSelection.elementIds.push(i);
            this.addToAttributeArraysSelection(this.defaultNodeSelection, "node", this._nodes[i].id());
        }
        this.defaultNodeSelection.color = "#000000";
        this.defaultNodeSelection.showColor = false;
        this.defaultNodeSelection.priority = 10000;
        this.selectionColor_pointer--;
        this.defaultLinkSelection = this.createSelection("link");
        this.defaultLinkSelection.name = "Unselected";
        for (let i = 0; i < this._links.length; i++) {
            this.defaultLinkSelection.elementIds.push(i);
            this.addToAttributeArraysSelection(this.defaultLinkSelection, "link", this._links[i].id());
        }
        this.defaultLinkSelection.color = "#000000";
        this.defaultLinkSelection.showColor = false;
        this.defaultLinkSelection.priority = 10000;
        this.selectionColor_pointer--;
        // create selections for node types
        let types = [];
        let type, index;
        let selection;
        const nodeSelections = [];
        for (let i = 0; i < this.nodeArrays.nodeType.length; i++) {
            type = this.nodeArrays.nodeType[i];
            if (type == undefined || type.length == 0 || type == "undefined")
                continue;
            index = types.indexOf(type);
            if (index == -1) {
                selection = this.createSelection("node");
                selection.name = type;
                nodeSelections.push(selection);
                types.push(type);
            }
            else {
                selection = nodeSelections[index];
            }
            this.addElementToSelection(selection, this._nodes[i]);
            // this.addToSelection(selection, this._nodes[i].id(), 'node');
        }
        if (nodeSelections.length == 1) {
            console.log("nodeSelections[0]:", nodeSelections[0]);
            nodeSelections[0].color = "#444";
        }
        // create selections for link type
        types = [];
        const linkSelections = [];
        for (let i = 0; i < this.linkArrays.linkType.length; i++) {
            type = this.linkArrays.linkType[i];
            if (!type || type == "undefined")
                continue;
            index = types.indexOf(type);
            if (index == -1) {
                selection = this.createSelection("link");
                selection.name = type;
                linkSelections.push(selection);
                types.push(type);
            }
            else {
                selection = linkSelections[index];
            }
            this.addElementToSelection(selection, this._links[i]);
            // this.addToSelection(selection, this._links[i].id(), 'link');
        }
        if (linkSelections.length == 1)
            linkSelections[0].color = "#444";
        // create selections for node type
        // types = [];
        // var nodeSelections: Selection[] = [];
        // for (var i = 0; i < this.nodeArrays.nodeType.length; i++) {
        //     type = this.nodeArrays.nodeType[i];
        //     if (!type || type == 'undefined')
        //         continue;
        //     index = types.indexOf(type);
        //     if (index == -1) {
        //         selection = this.createSelection('node');
        //         selection.name = type;
        //         nodeSelections.push(selection)
        //         types.push(type);
        //     } else {
        //         selection = nodeSelections[index];
        //     }
        //     this.addElementToSelection(selection, this._nodes[i]);
        //     // this.addToSelection(selection, this._links[i].id(), 'link');
        // }
        this.currentSelection_id = 0;
    }
    // GRAPH API //////////////////
    /**
     *
     * Returns a window graph for the passed time point
     * or period
     * @param  {any}    start First time point of this graph
     * @param  {any}    end   Last time point of this graph.
     * @return {[type]}       [description]
     */
    // getGraph(start: Time, end?: Time): WindowGraph {
    //     var g: WindowGraph = new WindowGraph();
    //     return this.createGraph(g, start, end);
    // }
    // Creates a new graph with all nodes and edges from start to end.
    // CACHEGRAPH : this code needs to be leveraged to initialize all of the fields from
    // windowGraph that are now part of this class
    createGraphObjects(shouldCreateTimes, shouldCreateLinkTypes) {
        // measure time:
        console.log("[DynamicNetwork:createGraph()] >>> ");
        const d = Date.now();
        // POPULATE WINDOW GRAPH
        // populate locations
        if (this.locationArrays && "id" in this.locationArrays) {
            for (let i = 0; i < this.locationArrays.id.length; i++) {
                this._locations.push(new Location(this.locationArrays.id[i], this));
            }
        }
        else {
            this.locationArrays = new LocationArray();
        }
        // Populate nodes
        const nodes = [];
        if ("nodeArrays" in this && this.nodeArrays) {
            for (let i = 0; i < this.nodeArrays.id.length; i++) {
                nodes.push(new Node(i, this));
            }
        }
        // Populate links
        const links = [];
        let link;
        if ("linkArrays" in this && this.linkArrays) {
            for (let i = 0; i < this.linkArrays.source.length; i++) {
                link = new Link(i, this);
                links.push(link);
            }
        }
        // Populate node pairs
        let pairLinks;
        if ("nodePairArrays" in this && this.nodePairArrays) {
            for (let i = 0; i < this.nodePairArrays.length; i++) {
                pairLinks = this.nodePairArrays.links[i];
                this._nodePairs.push(new NodePair(i, this));
                // for (var j = 0; j < pairLinks.length; j++) {
                //     pairLinkId = pairLinks[j];
                //     pair = undefined;
                //     for (var k = 0; k < nodePairs.length; k++) {
                //         if (nodePairs[k].id == i) {
                //             pair = nodePairs[k];
                //             break;
                //         }
                //     }
                //     if (!pair) {
                //         pair = new NodePair(i, this);
                //         nodePairs.push(pair)
                //         thisGraphNodePairIds.push(i)
                //         pair.source = nodes[this.pairAttr('source', i)];
                //         pair.target = nodes[this.pairAttr('target', i)];
                //     }
                //     for (var k = 0; k < links.length; k++) {
                //         if (links[k].id == pairLinkId) {
                //             link = links[k];
                //             break;
                //         }
                //     }
                //     pair.links.push(link);
                //     link.nodePair = pair;
                // }
            }
        }
        this._nodes = nodes;
        this._links = links;
        // this.nodePairs = nodePairs;
        if (shouldCreateTimes) {
            // && 'timesArrays' in this && this.timeArrays) {
            this._times = [];
            for (let i = 0; i < this.timeArrays.length; i++)
                this._times.push(new Time(i, this));
        }
        // if (shouldCreateLinkTypes) {
        //     var linkTypeCount: number = this.linkTypeArrays.length;
        //     var colorScale;
        //     if (linkTypeCount <= 10) {
        //         colorScale = d3.scale.category10();
        //     } else {
        //         colorScale = d3.scale.category20();
        //     }
        //     for (var i = 0; i < this.linkTypeArrays.name.length; i++) {
        //         this.linkTypes.push(new LinkType(
        //             this.linkTypeArrays.id[i],
        //             this.linkTypeArrays.name[i],
        //             this.linkTypeArrays.color[i]
        //         ));
        //     }
        // }
        console.log("[DynamicNetwork:getGraph()] <<< ", Date.now() - d, "msec");
    }
    // all attribute accessor method
    nodeAttr(attr, id) {
        return this.attr(attr, id, "node");
    }
    linkAttr(attr, id) {
        return this.attr(attr, id, "link");
    }
    pairAttr(attr, id) {
        return this.attr(attr, id, "nodePair");
    }
    timeAttr(attr, id) {
        return this.attr(attr, id, "time");
    }
    get startTime() {
        return this._times[0];
    }
    get endTime() {
        return this._times[this._times.length - 1];
    }
    // /// SELECTIONS
    // // selections store ids of objects only.
    highlight(action, idCompound) {
        if (action == 'freeze') {
            this.highlight("resetFreeze");
            this.highlight("addFreeze", idCompound);
            return;
        }
        if (action == "resetFreeze") {
            // reset all
            this.highlightFreezeArrays.nodeIds = [];
            this.highlightFreezeArrays.linkIds = [];
            this.highlightFreezeArrays.nodePairIds = [];
            this.highlightFreezeArrays.timeIds = [];
            return;
        }
        if (action == "reset") {
            // reset all
            this.highlightArrays.nodeIds = [];
            this.highlightArrays.linkIds = [];
            this.highlightArrays.nodePairIds = [];
            this.highlightArrays.timeIds = [];
            return;
        }
        if (!idCompound) {
            console.error("[DynamicGraph] highlight: idCompound not set!");
            return;
        }
        if (action == "set") {
            this.highlight("reset");
            this.highlight("add", idCompound);
            return;
        }
        if (action == "add") {
            for (const type in idCompound) {
                for (let i = 0; i < idCompound[type].length; i++) {
                    this.highlightArrays[type].push(idCompound[type][i]);
                }
            }
        }
        else if (action == "remove") {
            let index;
            for (const type in idCompound) {
                for (let i = 0; i < idCompound[type].length; i++) {
                    index = this.highlightArrays[type].indexOf(idCompound[type][i]);
                    if (index >= 0)
                        this.highlightArrays[type].splice(index, 1);
                }
            }
        }
        if (action == "addFreeze") {
            for (const type in idCompound) {
                for (let i = 0; i < idCompound[type].length; i++) {
                    this.highlightFreezeArrays[type].push(idCompound[type][i]);
                }
            }
        }
        else if (action == "removeFreeze") {
            let index;
            for (const type in idCompound) {
                for (let i = 0; i < idCompound[type].length; i++) {
                    index = this.highlightFreezeArrays[type].indexOf(idCompound[type][i]);
                    if (index >= 0)
                        this.highlightFreezeArrays[type].splice(index, 1);
                }
            }
        }
    }
    // SELECT
    selection(action, idCompound, selectionId) {
        if (selectionId == undefined)
            selectionId = this.currentSelection_id;
        const selection = this.getSelection(selectionId);
        if (!selection) {
            console.error("[DynamicGraph] Selection with ", selectionId, "not found in ", this.selections);
            return; // WITH RETURN ?
        }
        if (action == "set") {
            const c = new IDCompound();
            c[selection.acceptedType + 's'] = selection.elementIds;
            this.selection("remove", c, selectionId);
            this.selection("add", idCompound, selectionId);
        }
        else if (action == "add") {
            idCompound.linkIds.forEach((v) => this.addToSelectionByTypeAndId(selection, "link", v));
            idCompound.nodeIds.forEach((v) => this.addToSelectionByTypeAndId(selection, "node", v));
            idCompound.timeIds.forEach((v) => this.addToSelectionByTypeAndId(selection, "time", v));
            idCompound.nodePairIds.forEach((v) => this.addToSelectionByTypeAndId(selection, "nodePair", v));
        }
        else if (action == "remove") {
            idCompound.linkIds.forEach((v) => this.removeFromSelectionByTypeAndId(selection, "link", v));
            idCompound.nodeIds.forEach((v) => this.removeFromSelectionByTypeAndId(selection, "node", v));
            idCompound.timeIds.forEach((v) => this.removeFromSelectionByTypeAndId(selection, "time", v));
            idCompound.nodePairIds.forEach((v) => this.removeFromSelectionByTypeAndId(selection, "nodePair", v));
        }
    }
    // SELFIX : delegate to dgraph
    addToAttributeArraysSelection(selection, type, id) {
        // check for priority of selections, then add where appropriate
        const elementSelections = this.attributeArrays[type].selections[id];
        for (let i = 0; i < elementSelections.length; i++) {
            if (elementSelections[i].priority > selection.priority) {
                this.attributeArrays[type].selections[id].splice(i, 0, selection);
                return;
            }
        }
        // if not already selected and if not higher priority than any other
        // selection, append to the end.
        this.attributeArrays[type].selections[id].push(selection);
    }
    // SELFIX : delegate to dgraph
    removeFromAttributeArraysSelection(selection, type, id) {
        const arr = this.attributeArrays[type].selections[id];
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] == selection)
                this.attributeArrays[type].selections[id].splice(i, 1);
        }
    }
    addElementToSelection(selection, e) {
        this.addToSelectionByTypeAndId(selection, e.type, e.id());
    }
    addToSelectionByTypeAndId(selection, type, id) {
        if (type != selection.acceptedType) {
            console.log("attempting to put object of the wrong type into a selection. " + type + ' !=' + selection.acceptedType);
            return; // don't proceed with selection;
        }
        selection.elementIds.push(id);
        this.addToAttributeArraysSelection(selection, type, id);
        // =======
        //                 this.selection('add', idCompound, selectionId);
        //             } else {
        //                 if (action == 'add') {
        //                     for (var field in idCompound) {
        //                         for (var i = 0; i < idCompound[field].length; i++) {
        //                             this.addToSelection(selection, idCompound[field][i], field)
        //                         }
        //                     }
        //                 } else {
        //                     if (action == 'remove') {
        //                         for (var field in idCompound) {
        //                             for (var i = 0; i < idCompound[field].length; i++) {
        //                                 for (var j = 0; j < selection.elementIds.length; j++) {
        //                                     if (selection.elementIds[j] == idCompound[field][i].id) {
        //                                         this.removeFromSelection(selection, idCompound[field][i], field);
        //                                     }
        //                                 }
        //                             }
        //                         }
        //                     }
        //                 }
        //             }
        //         }
        //         addToSelection(selection: Selection, id:number, elementType:string) {
        //             selection.elementIds.push(id);
        //             var e:BasicElement = this.get(elementType, id);
        //             e.addToSelection(selection);
        // >>>>>>> api
        // remove from default selection
        let i;
        if (type == "node") {
            i = this.defaultNodeSelection.elementIds.indexOf(id);
            if (i > -1) {
                this.removeFromAttributeArraysSelection(this.defaultNodeSelection, type, id);
                this.defaultNodeSelection.elementIds.splice(i, 1);
            }
        }
        else if (type == "link") {
            i = this.defaultLinkSelection.elementIds.indexOf(id);
            if (i > -1) {
                this.removeFromAttributeArraysSelection(this.defaultLinkSelection, type, id);
                this.defaultLinkSelection.elementIds.splice(i, 1);
            }
        }
    }
    // <<<<<<< HEAD
    removeElementFromSelection(selection, e) {
        this.removeFromSelectionByTypeAndId(selection, e.type, e.id());
    }
    removeFromSelectionByTypeAndId(selection, type, id) {
        // selection.elements.push(compound[field][i])
        // e.addToSelection(selection);
        // =======
        //         removeFromSelection(selection: Selection, id:number, elementType:string) {
        // >>>>>>> api
        const i = selection.elementIds.indexOf(id);
        if (i == -1)
            return;
        selection.elementIds.splice(i, 1);
        // <<<<<<< HEAD
        this.removeFromAttributeArraysSelection(selection, type, id);
        // =======
        //             var e:BasicElement = this.get(elementType, id);
        //             e.removeFromSelection(selection);
        // >>>>>>> api
        // add to default selection
        if (this.getSelectionsByTypeAndId(type, id).length == 0) {
            if (type == "node") {
                this.defaultNodeSelection.elementIds.push(id);
                this.addToAttributeArraysSelection(this.defaultNodeSelection, type, id);
            }
            else if (type == "link") {
                this.defaultLinkSelection.elementIds.push(id);
                this.addToAttributeArraysSelection(this.defaultLinkSelection, type, id);
            }
        }
    }
    getSelectionsByTypeAndId(type, id) {
        return this.attributeArrays[type].selections[id];
    }
    filterSelection(selectionId, filter) {
        const selection = this.getSelection(selectionId);
        if (selection != undefined) {
            selection.filter = filter;
        }
    }
    isFiltered(id, type) {
        return this.attributeArrays[type + "s"].filter;
    }
    isHighlighted(id, type) {
        return this.highlightArrays[type + "Ids"].indexOf(id) > -1
            || this.highlightFreezeArrays[type + "Ids"].indexOf(id) > -1;
    }
    isFrozen(id, type) {
        return this.highlightFreezeArrays[type + "Ids"].indexOf(id) > -1;
    }
    getHighlightedIds(type) {
        return this.highlightArrays[type + "Ids"];
    }
    setCurrentSelection(id) {
        // [bbach] why should we ignore them?
        // if (id < 2) // i.e. either default node or link selection..
        //     return;  // ignore
        console.log("[DynamicGraph] setCurrentSelectionId ", id);
        this.currentSelection_id = id;
    }
    getCurrentSelection() {
        // before onoly Selection!
        return this.getSelection(this.currentSelection_id);
    }
    addSelection(id, color, acceptedType, priority) {
        const s = this.createSelection(acceptedType);
        s.id = id;
        s.color = color;
        s.priority = priority;
    }
    // creates a selection for the passed type.
    createSelection(type) {
        const s = new Selection(this.selections.length, type);
        s.color = this.BOOKMARK_COLORS(this.selectionColor_pointer % 10);
        this.selectionColor_pointer++;
        this.selections.push(s);
        return s;
    }
    deleteSelection(selectionId) {
        const s = this.getSelection(selectionId);
        // remove all elements from this selection
        // <<<<<<< HEAD
        //             var compound: ElementCompound = new ElementCompound();
        //             compound[s.acceptedType + 'Ids'] = s.elementIds.slice(0);
        //             this.selection('remove', compound, s.id)
        // =======
        // remove
        if (s != undefined) {
            const idCompound = new IDCompound();
            idCompound[s.acceptedType + "Ids"] = s.elementIds.slice(0);
            console.log("Delete selection->remove elemeents", s.elementIds.slice(0));
            this.selection("remove", idCompound, s.id);
            // >>>>>>> api
            // delete selection
            this.selections.splice(this.selections.indexOf(s), 1);
        }
    }
    setSelectionColor(id, color) {
        const s = this.getSelection(id);
        if (!s) {
            return;
        }
        s.color = color;
    }
    getSelections(type) {
        const selections = [];
        if (type) {
            for (let i = 0; i < this.selections.length; i++) {
                if (this.selections[i].acceptsType(type))
                    selections.push(this.selections[i]);
            }
            return selections;
        }
        else {
            return this.selections;
        }
    }
    getSelection(id) {
        // before only Selection return
        for (let i = 0; i < this.selections.length; i++) {
            if (id == this.selections[i].id)
                return this.selections[i];
        }
        console.error("[DynamicGraph] No selection with id ", id, "found!");
        /* If not found ?? */
        return undefined;
    }
    clearSelections() {
        this.selections = [];
    }
    // internal utils
    getTimeIdForUnixTime(unixTime) {
        // before only number
        let timeId;
        console.log("unixTime: ");
        console.log(unixTime);
        for (timeId = 0; timeId < this.timeArrays.length; timeId++) {
            if (unixTime == this.timeArrays.unixTime[timeId]) {
                return timeId;
            }
        }
        console.error("Time object for unix time", unixTime, "not found!");
        return undefined;
    }
    // ORDERING
    /* adds an specific node order (e.g. alphabetical) */
    // go into dynamicgraph
    addNodeOrdering(name, order) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                console.error("Ordering", name, "already exists");
                return;
            }
        }
        const o = new Ordering(name, order);
        this.nodeOrders.push(o);
    }
    setNodeOrdering(name, order) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                this.nodeOrders[i].order = order;
                return;
            }
        }
        console.error("Ordering", name, "does not exist");
    }
    removeNodeOrdering(name, order) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                this.nodeOrders.splice(i, 1);
            }
        }
    }
    getNodeOrder(name) {
        for (let i = 0; i < this.nodeOrders.length; i++) {
            if (this.nodeOrders[i].name == name) {
                return this.nodeOrders[i];
            }
        }
        console.error("Ordering", name, "not found!");
        return;
    }
    // returns elements
    nodes() {
        return new NodeQuery(this.nodeArrays.id, this);
    }
    links() {
        return new LinkQuery(this.linkArrays.id, this);
    }
    times() {
        return new TimeQuery(this.timeArrays.id, this);
    }
    locations() {
        return new LocationQuery(this.locationArrays.id, this);
    }
    nodePairs() {
        return new NodePairQuery(this.nodePairArrays.id, this);
    }
    linksBetween(n1, n2) {
        let nodePairId = this.matrix[n1.id()][n2.id()];
        if (nodePairId == undefined)
            nodePairId = this.matrix[n2.id()][n1.id()];
        if (nodePairId == undefined)
            return new LinkQuery([], this);
        /* UNDEFINED? */
        const node_pair = this.nodePair(nodePairId);
        if (node_pair != undefined)
            return new LinkQuery(node_pair.links().toArray(), this);
        else
            return new LinkQuery([], this);
    }
    // generic accessor method. should not be used externally
    get(type, id) {
        if (type.indexOf("nodePair") > -1)
            return this.nodePair(id);
        if (type.indexOf("node") > -1)
            return this.node(id);
        if (type.indexOf("link") > -1)
            return this.link(id);
        if (type.indexOf("time") > -1)
            return this.time(id);
        if (type.indexOf("locations") > -1)
            return this.location(id);
    }
    getAll(type) {
        if (type == "nodes")
            return this.nodes();
        if (type == "links")
            return this.links();
        if (type == "times")
            return this.times();
        if (type == "nodePairs")
            return this.nodePairs();
        // if (type == 'locations')
        return this.locations();
    }
    // returns the node with ID
    node(id) {
        for (let i = 0; i < this._nodes.length; i++) {
            if (this._nodes[i].id() == id)
                return this._nodes[i];
        }
    }
    link(id) {
        for (let i = 0; i < this._links.length; i++) {
            if (this._links[i].id() == id)
                return this._links[i];
        }
    }
    time(id) {
        for (let i = 0; i < this._times.length; i++) {
            if (this._times[i].id() == id)
                return this._times[i];
        }
    }
    location(id) {
        for (let i = 0; i < this._locations.length; i++) {
            if (this._locations[i].id() == id)
                return this._locations[i];
        }
    }
    nodePair(id) {
        for (let i = 0; i < this._nodePairs.length; i++) {
            if (this._nodePairs[i].id() == id)
                return this._nodePairs[i];
        }
    }
    getMinGranularity() {
        return this.gran_min;
    }
    getMaxGranularity() {
        return this.gran_max;
    }
}
// A time series with one scalar value for every time point
export class AttributeArray {
    constructor() {
        this.id = [];
    }
    get length() {
        return this.id.length;
    }
}
export class NodeArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.id = [];
        this.label = [];
        // nodeType: ScalarTimeSeries<string>[] = [];
        this.outLinks = []; // contains link ids only, since every GRAPH has its own EDGE object instance
        this.inLinks = []; // contains link ids only, since every GRAPH has its own EDGE object instance
        this.links = [];
        this.outNeighbors = []; // contains node ids only, since every GRAPH has its own NODE object instance
        this.inNeighbors = []; // contains node ids only, since every GRAPH has its own NODE object instance
        this.neighbors = [];
        this.selections = [];
        this.attributes = []; // arbitrary attributes (key -> value)
        this.locations = [];
        this.filter = [];
        this.nodeType = [];
        this.color = [];
        this.shape = [];
    }
}
export class LinkArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.source = [];
        this.target = [];
        this.linkType = [];
        this.directed = [];
        this.nodePair = []; // before number but it don't accept undefined
        // array of all time ids (temporally ordered) when this link is present
        this.presence = [];
        // array of weights per time this link is present. This is a generic field
        // that can be used for weights, e.g.
        this.weights = [];
        this.selections = [];
        this.filter = [];
        this.attributes = new Object(); // arbitrary attributes (key -> value)
    }
}
export class NodePairArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.source = [];
        this.target = [];
        this.links = [];
        this.selections = [];
        this.filter = [];
    }
}
export class TimeArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.id = [];
        this.momentTime = []; // moment object
        this.label = [];
        this.unixTime = []; // unix time object
        this.selections = [];
        this.filter = [];
        this.links = []; // all links at that time
    }
}
export class LinkTypeArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.name = [];
        this.count = [];
        this.color = [];
        this.filter = [];
    }
}
export class NodeTypeArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.name = [];
        this.count = [];
        this.color = [];
        this.filter = [];
    }
}
export class LocationArray extends AttributeArray {
    constructor() {
        super(...arguments);
        this.id = [];
        this.label = [];
        this.longitude = [];
        this.latitude = [];
        this.x = [];
        this.y = [];
        this.z = [];
        this.radius = [];
    }
}
export class NodeType {
    constructor(id, name, color) {
        this.id = id;
        this.name = name;
        this.color = color;
    }
}
export class Ordering {
    constructor(name, order) {
        this.order = [];
        this.name = name;
        this.order = order;
    }
}
/* MOVED FROM QUERIES TO DYNAMICGRAPH */
//// QUERIES
export class Query {
    constructor(elements) {
        this._elements = [];
        if (elements) {
            for (let i = 0; i < elements.length; i++) {
                if (elements[i] != undefined)
                    this._elements.push(elements[i]);
            }
        }
    }
    // contains(element: number): boolean {
    //     return this._elements.indexOf(element) > -1;
    // }
    addUnique(element) {
        if (this._elements.indexOf(element) == -1)
            this._elements.push(element);
    }
    add(element) {
        this._elements.push(element);
    }
    addAll(elements) {
        for (let i = 0; i < elements.length; i++) {
            if (elements[i] != undefined)
                this._elements.push(elements[i]);
        }
    }
    addAllUnique(elements) {
        for (let i = 0; i < elements.length; i++) {
            this.addUnique(elements[i]);
        }
    }
    /** @returns numbr of elements in this query. Same as size(). */
    get length() {
        return this._elements.length;
    }
    /** @returns numbr of elements in this query. Same as length getter. */
    size() {
        return this._elements.length;
    }
    /** @returns all ids in this query. */
    ids() {
        return this._elements;
    }
    removeDuplicates() {
        const elements = this._elements.slice(0);
        this._elements = [];
        for (let i = 0; i < elements.length; i++) {
            if (this._elements.indexOf(elements[i]) == -1)
                this._elements.push(elements[i]);
        }
        return this;
    }
    generic_intersection(q) {
        const intersection = [];
        for (let i = 0; i < this._elements.length; i++) {
            for (let j = 0; j < q._elements.length; j++) {
                if (this._elements[i] == q._elements[j]) {
                    intersection.push(this._elements[i]);
                }
            }
        }
        return new Query(intersection);
    }
}
export class GraphElementQuery extends Query {
    constructor(elements, g, elementType) {
        super(elements);
        this.g = g;
        this.elementType = elementType;
    }
    /** @returns a query that contains only the elements matching
     * the filter critera;
     * @param attribute - name of attribute that is used on filter
     * @param filter - function evaluating if the attribute's value is valid.
     */
    generic_filter(filter) {
        const arr = [];
        for (let i = 0; i < this._elements.length; i++) {
            try {
                if (filter(this.g.get(this.elementType, this._elements[i]))) {
                    arr.push(this._elements[i]);
                }
            }
            catch (ex) {
                // TODO: catch this exception?
            }
        }
        return arr;
    }
    /** @returns a query with selected elements, i.e. elements that are in at least
     * one selection.
     */
    generic_selected() {
        const arr = [];
        for (let i = 0; i < this._elements.length; i++) {
            const element = this.g.get(this.elementType, this._elements[i]);
            if (element != undefined && element.isSelected()) {
                arr.push(this._elements[i]);
            }
        }
        return arr;
    }
    /** @returns a query with visible elements.
     */
    generic_visible() {
        const arr = [];
        for (let i = 0; i < this._elements.length; i++) {
            const element = this.g.get(this.elementType, this._elements[i]);
            if (element != undefined && element.isVisible()) {
                arr.push(this._elements[i]);
            }
        }
        return arr;
    }
    /** @returns a query with highighted elements.
     */
    generic_highlighted() {
        const arr = [];
        for (let i = 0; i < this._elements.length; i++) {
            const element = this.g.get(this.elementType, this._elements[i]);
            if (element != undefined && element.isHighlighted()) {
                arr.push(this._elements[i]);
            }
        }
        return arr;
    }
    /** @returns a query with only the elements present in the specified time step
     * or period.
     */
    generic_presentIn(start, end) {
        const arr = [];
        for (let i = 0; i < this._elements.length; i++) {
            const element = this.g.get(this.elementType, this._elements[i]);
            if (element != undefined && element.presentIn(start, end)) {
                arr.push(this._elements[i]);
            }
        }
        return arr;
    }
    /** @returns this query with elements sorted */
    generic_sort(attrName, asc) {
        if (this._elements.length == 0) {
            return this;
        }
        const array = this._elements.slice(0);
        // ITS POSSIBLE AN UNDEFINED VALUE??
        array.sort((e1, e2) => {
            const e1_get = this.g.get(this.elementType, e1);
            const e2_get = this.g.get(this.elementType, e2);
            if (e1_get != undefined && e2_get != undefined) {
                return attributeSort(e1_get, e2_get, attrName, asc);
            }
            else if (e1_get == undefined && e2_get == undefined) {
                return 0;
            }
            return e1_get == undefined ? 1 : -1;
        });
        this._elements = array;
        return this;
    }
    generic_removeDuplicates() {
        const uniqueElements = [];
        for (let i = 0; i < this._elements.length; i++) {
            // for(var j=i+1 ; j <this._elements.length ; j++){
            //     if(this._elements[i]==this._elements[j])
            //         this._elements.slice(j,1);
            // }
            if (uniqueElements.indexOf(this._elements[i]) == -1)
                uniqueElements.push(this._elements[i]);
        }
        this._elements = uniqueElements;
        return this;
    }
}
/** Basic class for every object in networkcube with an ID.
 * A BasicElement is a wrapper to the DynamicGraph and that
 * represents any object, i.e. node, link, node pair, time, location.
 */
export class BasicElement {
    // CONSTRUCTOR
    constructor(id, type, dynamicGraph) {
        this._id = id;
        this.type = type;
        this.g = dynamicGraph;
    }
    // GETTER
    /** @returns the object's id */
    id() {
        return this._id;
    }
    /** Generic method to return an attribute value for this element
     * @param attr: attribute name on this object.
     * @returns the attribute's value. */
    attr(attr) {
        return this.g.attr(attr, this._id, this.type);
    }
    // SELECTIONS
    /** @returns all selections this object is part of. */
    getSelections() {
        return this.g.attributeArrays[this.type].selections[this._id];
    }
    /** Adds this object to a selection
     * @param selection - the Selection object
     */
    addToSelection(b) {
        this.g.attributeArrays[this.type].selections[this._id].push(b);
    }
    /** Removes this object from a selection.
     * @param selection - the Selection objects
     */
    removeFromSelection(b) {
        const arr = this.g.attributeArrays[this.type]
            .selections[this._id];
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] == b)
                this.g.attributeArrays[this.type].selections[this._id].splice(i, 1);
        }
    }
    inSelection(s) {
        return this.getSelections().indexOf(s) > -1;
    }
    // DISPLAY STATES
    /** @returns true if this object is selected.
     * @param selection - (optional) if specified returns true if this object
     * is in the passed selection.
     */
    isSelected(selection) {
        if (!selection)
            return this.getSelections().length > 0;
        const selections = this.g.attributeArrays[this.type].selections[this._id];
        for (let i = 0; i < selections.length; i++) {
            // start with 1 to avoid default selection.
            if (selections[i] == this.g.defaultNodeSelection ||
                selections[i] == this.g.defaultLinkSelection) {
                continue;
            }
            if (selections[i] == selection)
                return true;
        }
        return false;
    }
    /** @returns true if this object is highlighted */
    isHighlighted() {
        return this.g.isHighlighted(this._id, this.type);
    }
    /** @returns true if this object is highlighted frozen */
    isFrozen() {
        return this.g.isFrozen(this._id, this.type);
    }
    /** @returns true if this object is filtered, i.e. removed from display. */
    isFiltered() {
        return this.g.isFiltered(this._id, this.type);
    }
    /** @returns true if this object is visible. */
    isVisible() {
        const selections = this.getSelections();
        if (selections.length == 0)
            return true;
        for (let i = 0; i < selections.length; i++) {
            if (selections[i].filter)
                return false;
        }
        return true;
    }
    // OTHER QUERIES
    /** @returns true if this object is present in the graph
     * in a specific time or a time period.
     * @param start -  start time. If only this parameter is passed to the
     * function, method returns if this object is present in this time step.
     * @param end - end time. If this parameter is specified, returns if this
     * object is present between start and end.
     */
    presentIn(start, end) {
        const presence = this.attr("presence");
        if (!end)
            end = start;
        for (let i = start._id; i <= end._id; i++) {
            if (presence.indexOf(i) > -1)
                return true;
        }
        return false;
    }
}
/** A time series with a scalar value per time step.
 * This class nestes an object that holds information for time
 * steps in the format key->value. I.e. the value for the
 * time step with ID 3 is accessed by this.3   */
export class ScalarTimeSeries {
    constructor() {
        this.serie = {};
    }
    /** @returns a ScalarTimeSeries for the specified period. */
    period(t1, t2) {
        const t1id = t1.id();
        const t2id = t2.id();
        const s = new ScalarTimeSeries();
        for (const prop in this.serie) {
            if (parseInt(prop) >= t1id && parseInt(prop) <= t2id) {
                s.serie[prop] = this.serie[prop];
            }
        }
        return s;
    }
    /** Sets a value for a specified time point. */
    set(t, element) {
        this.serie[t.id()] = element;
    }
    /** @returns the value for a specified time point. */
    get(t) {
        // before T!!
        if (this.serie[t.id()] == undefined)
            return; // this is avoid!!
        return this.serie[t.id()];
    }
    size() {
        return this.toArray().length;
    }
    getSerie() {
        return this.serie;
    }
    /** Returns all values as array.
     * @param removeDuplicates
     * @returns array with values;
     */
    toArray(removeDuplicates) {
        if (removeDuplicates == undefined)
            removeDuplicates = false;
        const a = [];
        if (removeDuplicates) {
            for (const prop in this.serie) {
                a.push(this.serie[prop]);
            }
        }
        else {
            for (const prop in this.serie) {
                if (a.indexOf(this.serie[prop]) == -1)
                    a.push(this.serie[prop]);
            }
        }
        return a;
    }
}
/** A time series with an array per time step.
 * This class nestes an object that holds information for time
 * steps in the format key->value. I.e. the value for the
 * time step with ID 3 is accessed by this.3   */
export class ArrayTimeSeries {
    constructor() {
        this.serie = {};
    }
    period(t1, t2) {
        const t1id = t1.id();
        const t2id = t1.id();
        const s = new ArrayTimeSeries();
        for (const prop in this.serie) {
            if (parseInt(prop) >= t1id && parseInt(prop) <= t1id) {
                s.serie[prop] = this.serie[prop];
            }
        }
        return s;
    }
    add(t, element) {
        if (t == undefined) {
            return;
        }
        if (!this.serie[t._id])
            this.serie[t._id] = [];
        this.serie[t._id].push(element);
    }
    get(t) {
        return this.serie[t._id];
    }
    toArray() {
        const a = [];
        for (const prop in this.serie) {
            a.push(this.serie[prop]);
        }
        return a;
    }
    toFlatArray(removeDuplicates) {
        if (removeDuplicates == undefined)
            removeDuplicates = false;
        const a = [];
        for (const prop in this.serie) {
            for (let i = 0; i < this.serie[prop].length; i++) {
                if (!removeDuplicates ||
                    (removeDuplicates && a.indexOf(this.serie[prop]) == -1)) {
                    a.push(this.serie[prop][i]);
                }
            }
        }
        return a;
    }
}
export class TimeQuery extends GraphElementQuery {
    //elementType = 'time';
    constructor(elements, g) {
        super(elements, g, "time");
        //this.elementType = 'time';
        if (elements.length > 0 && elements[0] instanceof Time) {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i].id());
            }
        }
        if (elements.length > 0 && typeof elements[0] == "number") {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i]);
            }
        }
    }
    contains(t) {
        return this._elements.indexOf(t.id()) > -1;
    }
    highlighted() {
        return new TimeQuery(super.generic_highlighted(), this.g);
    }
    visible() {
        return new TimeQuery(super.generic_visible(), this.g);
    }
    selected() {
        return new TimeQuery(super.generic_selected(), this.g);
    }
    filter(filter) {
        return new TimeQuery(super.generic_filter(filter), this.g);
    }
    presentIn(t1, t2) {
        return new TimeQuery(super.generic_presentIn(t1, t2), this.g);
    }
    sort(attributeName) {
        return super.generic_sort(attributeName);
    }
    links() {
        let links = [];
        // var allLinks = this.g.links().toArray();
        // var allTimes = this.g.times().toArray();
        // for(var i=0 ; i<allLinks.length ; i++){
        // for(var j=0 ; j<allTimes.length ; j++){
        //     if(allLinks[i].presentIn(allTimes[j])){
        //         links.push(allLinks[i].id());
        //         break
        //     }
        // }
        // }
        for (let i = 0; i < this._elements.length; i++) {
            links = links.concat(this.g.attr("links", this._elements[i], "time"));
        }
        return new LinkQuery(links, this.g);
    }
    // returns the i-th element in this query
    get(i) {
        return this.g._times[this._elements[i]];
    }
    last() {
        return this.g._times[this._elements[this._elements.length - 1]];
    }
    // return array of times
    toArray() {
        const a = [];
        const allTimes = this.g._times;
        for (let i = 0; i < this._elements.length; i++) {
            a.push(allTimes[this._elements[i]]);
        }
        return a;
    }
    createAttribute(attrName, f) {
        // create and init new attribute array if necessary
        if (this.g.timeArrays[attrName] == undefined) {
            this.g.timeArrays[attrName] = [];
            for (let i = 0; i < this.g._times.length; i++) {
                this.g.timeArrays[attrName].push();
            }
        }
        for (let i = 0; i < this._elements.length; i++) {
            this.g.timeArrays[attrName][this._elements[i]] = f(this.g._times[this._elements[i]]);
        }
        return this;
    }
    unixTimes() {
        const unixTimes = [];
        for (let i = 0; i < this._elements.length; i++) {
            const time = this.g.time(this._elements[i]); // UNDEFINED ??
            if (time != undefined) {
                unixTimes.push(time.unixTime());
            }
        }
        return unixTimes;
    }
    intersection(q) {
        return new TimeQuery(this.generic_intersection(q)._elements, this.g);
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this.g.time(this._elements[i]), i);
        }
        return this;
    }
}
/**
 * Represents a Time object
 */
export class Time extends BasicElement {
    constructor(id, dynamicGraph) {
        super(id, "time", dynamicGraph);
        this.getWeek = timeFormat("%V");
    }
    // SPECIFIC ATTRIBUTE QUERIES
    /** @returns the Date object associated to this time object. */
    time() {
        return this.attr("momentTime");
    }
    moment() {
        return this.attr("momentTime");
    }
    label() {
        return this.attr("label");
    }
    /** @returns the unix time for this time object. */
    unixTime() {
        return this.attr("unixTime");
    }
    /** @returns a string label for this object. */
    // label(): String { return this.attr('label') + ''; }
    links() {
        // var links:number[] = [];
        // for(var i=0 ; i<allLinks.length ; i++){
        //     if(allLinks[i].presentIn(this))
        //         links.push(allLinks[i].id());
        // }
        return new LinkQuery(this.attr("links"), this.g);
    }
    // wrapper to moment.js
    year() {
        return this.time().getUTCFullYear();
    }
    month() {
        return this.time().getUTCMonth();
    }
    week() {
        return parseInt(this.getWeek(this.time()));
    }
    day() {
        return this.time().getUTCDay();
    }
    hour() {
        return this.time().getUTCHours();
    }
    minute() {
        return this.time().getUTCMinutes();
    }
    second() {
        return this.time().getUTCSeconds();
    }
    millisecond() {
        return this.time().getMilliseconds();
    }
    format(format) {
        const formatDate = timeFormat(format);
        return formatDate(this.time());
    }
}
export class LocationQuery extends GraphElementQuery {
    // elementType = 'location';
    constructor(elements, g) {
        super(elements, g, "location");
        // this.elementType = 'location';
        if (elements.length > 0 && elements[0] instanceof Location) {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements = elements[i].id();
            }
        }
        if (elements.length > 0 && typeof elements[0] == "number") {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i]);
            }
        }
    }
    contains(l) {
        return this._elements.indexOf(l.id()) > -1;
    }
    highlighted() {
        return new LocationQuery(super.generic_highlighted(), this.g);
    }
    visible() {
        return new LocationQuery(super.generic_visible(), this.g);
    }
    selected() {
        return new LocationQuery(super.generic_selected(), this.g);
    }
    filter(filter) {
        return new LocationQuery(super.generic_filter(filter), this.g);
    }
    presentIn(t1, t2) {
        return new LocationQuery(super.generic_presentIn(t1, t2), this.g);
    }
    sort(attributeName) {
        return super.generic_sort(attributeName);
    }
    // returns the i-th element in this query
    get(i) {
        return this.g._locations[this._elements[i]];
    }
    last() {
        return this.g._locations[this._elements[this._elements.length - 1]];
    }
    // return array of locations
    toArray() {
        const a = [];
        for (let i = 0; i < this._elements.length; i++) {
            a.push(this.g._locations[this._elements[i]]);
        }
        return a;
    }
    createAttribute(attrName, f) {
        // create and init new attribute array if necessary
        if (this.g.locationArrays[attrName] == undefined) {
            this.g.locationArrays[attrName] = [];
            for (let i = 0; i < this.g._locations.length; i++) {
                this.g.locationArrays[attrName].push();
            }
        }
        for (let i = 0; i < this._elements.length; i++) {
            this.g.locationArrays[attrName][this._elements[i]] = f(this.g._locations[this._elements[i]]);
        }
        return this;
    }
    intersection(q) {
        return new LocationQuery(this.generic_intersection(q)._elements, this.g);
    }
    removeDuplicates() {
        return new LocationQuery(this.generic_removeDuplicates()._elements, this.g);
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this.g.location(this._elements[i]), i);
        }
        return this;
    }
}
/**
 * Represents a simple array of numbers that can be used to calculate
 * max, mean, min values etc..
 */
export class NumberQuery extends Query {
    clone() {
        return this._elements.slice(0);
    }
    min() {
        this._elements = this.makeNumbers(this._elements);
        let min = parseInt(this._elements[0] + "");
        for (let i = 1; i < this._elements.length; i++) {
            if (this._elements[i] != undefined)
                min = Math.min(min, parseInt(this._elements[i] + ""));
        }
        return min;
    }
    max() {
        let max = parseInt(this._elements[0] + "");
        for (let i = 1; i < this._elements.length; i++) {
            if (this._elements[i] != undefined)
                max = Math.max(max, parseInt(this._elements[i] + ""));
        }
        return max;
    }
    mean() {
        this._elements = this.makeNumbers(this._elements);
        let v = 0;
        let count = 0;
        for (let i = 0; i < this._elements.length; i++) {
            if (typeof this._elements[i] == "number") {
                v += parseInt(this._elements[i] + "");
                count++;
            }
        }
        return v / count;
    }
    sum() {
        let sum = 0;
        for (let i = 0; i < this._elements.length; i++) {
            if (typeof this._elements[i] == "number") {
                sum += parseInt(this._elements[i] + "");
            }
        }
        return sum;
    }
    toArray() {
        return this._elements.slice(0);
    }
    get(index) {
        return this._elements[index];
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this._elements[i], i);
        }
        return this;
    }
    makeNumbers(elements) {
        if (elements && elements.length > 0) {
            const first = elements[0];
            if (typeof first == "string") {
                const numberElements = [];
                for (let i = 0; i < elements.length; i++) {
                    numberElements.push(parseFloat(elements[i] + ""));
                }
                console.log("string array converted", numberElements);
                return numberElements;
            }
        }
        return elements;
    }
}
export class Location extends BasicElement {
    constructor(id, graph) {
        super(id, "location", graph);
    }
    // SPECIFIC ATTRIBUTE QUERIES
    label() {
        return this.attr("label") + "";
    }
    longitude() {
        return this.attr("longitude");
    }
    latitude() {
        return this.attr("latitude");
    }
    x() {
        return this.attr("x");
    }
    y() {
        return this.attr("y");
    }
    z() {
        return this.attr("z");
    }
    radius() {
        return this.attr("radius");
    }
}
export class NodePairQuery extends GraphElementQuery {
    //elementType = 'nodePair';
    constructor(elements, g) {
        super(elements, g, "nodePair");
        //this.elementType = 'nodePair';
        if (elements.length > 0 && elements[0] instanceof NodePair) {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i].id());
            }
        }
        if (elements.length > 0 && typeof elements[0] == "number") {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i]);
            }
        }
    }
    contains(n) {
        return this._elements.indexOf(n.id()) > -1;
    }
    highlighted() {
        return new NodePairQuery(super.generic_highlighted(), this.g);
    }
    visible() {
        return new NodePairQuery(super.generic_visible(), this.g);
    }
    selected() {
        return new NodePairQuery(super.generic_selected(), this.g);
    }
    filter(filter) {
        return new NodePairQuery(super.generic_filter(filter), this.g);
    }
    presentIn(t1, t2) {
        return new NodePairQuery(super.generic_presentIn(t1, t2), this.g);
    }
    sort(attributeName) {
        return super.generic_sort(attributeName);
    }
    // returns the i-th element in this query
    get(i) {
        return this.g._nodePairs[this._elements[i]];
    }
    last() {
        return this.g._links[this._elements[this._elements.length - 1]];
    }
    // returns array of NodePair
    toArray() {
        const a = [];
        for (let i = 0; i < this._elements.length; i++) {
            a.push(this.g._nodePairs[this._elements[i]]);
        }
        return a;
    }
    createAttribute(attrName, f) {
        // create and init new attribute array if necessary
        if (this.g.nodePairArrays[attrName] == undefined) {
            this.g.nodePairArrays[attrName] = [];
            for (let i = 0; i < this.g._nodePairs.length; i++) {
                this.g.nodePairArrays[attrName].push();
            }
        }
        for (let i = 0; i < this._elements.length; i++) {
            this.g.nodePairArrays[attrName][this._elements[i]] = f(this.g._nodePairs[this._elements[i]]);
        }
        return this;
    }
    intersection(q) {
        return new NodePairQuery(this.generic_intersection(q)._elements, this.g);
    }
    removeDuplicates() {
        return new NodePairQuery(this.generic_removeDuplicates()._elements, this.g);
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this.g.nodePair(this._elements[i]), i);
        }
        return this;
    }
}
export class NodePair extends BasicElement {
    constructor(id, graph) {
        super(id, "nodePair", graph);
    }
    // SPECIFIC ATTRIBUTE QUERIES
    get source() {
        return this.g._nodes[this.attr("source")];
    }
    get target() {
        return this.g._nodes[this.attr("target")];
    }
    links() {
        return new LinkQuery(this.attr("links"), this.g);
    }
    nodeType() {
        return this.attr("nodeType");
    }
    presentIn(start, end) {
        for (let i = 0; i < this.links.length; i++) {
            if (this.links[i].presentIn(start, end))
                return true;
        }
        return false;
    }
}
export class StringQuery {
    constructor(elements) {
        if (elements)
            this._elements = elements.slice(0);
        else
            this._elements = []; // INIT WHEN ELEMENTS DOESN'T EXIST
    }
    contains(element) {
        return this._elements.indexOf(element) > -1;
    }
    addUnique(element) {
        if (this._elements.indexOf(element) == -1)
            this._elements.push(element);
    }
    add(element) {
        this._elements.push(element);
    }
    addAll(elements) {
        for (let i = 0; i < elements.length; i++) {
            if (elements[i] != undefined)
                this._elements.push(elements[i]);
        }
    }
    addAllUnique(elements) {
        for (let i = 0; i < elements.length; i++) {
            this.addUnique(elements[i]);
        }
    }
    get length() {
        return this._elements.length;
    }
    size() {
        return this._elements.length;
    }
    toArray() {
        return this._elements.slice(0);
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this._elements[i], i);
        }
        return this;
    }
}
function getBulkAttributes(attrName, ids, type, g, t1, t2) {
    let a = [];
    let temp;
    for (let i = 0; i < ids.length; i++) {
        if (t2 != undefined && t1 != undefined) {
            temp = g.attr(attrName, ids[i], type)
                .period(t1, t2)
                .toArray();
        }
        else if (t1 != undefined) {
            temp = [
                g.attr(attrName, ids[i], type).get(t1),
            ];
        }
        else {
            temp = (g.attr(attrName, ids[i], type)).toArray();
        }
        for (let j = 0; j < temp.length; j++) {
            if (temp[j] instanceof Array) {
                a = a.concat(temp[j]);
            }
            else {
                if (a.indexOf(temp[j]) == -1)
                    a.push(temp[j]);
            }
        }
    }
    return a;
}
export class NodeQuery extends GraphElementQuery {
    // elementType = 'node';
    constructor(elements, g) {
        super(elements, g, "node");
        if (elements.length > 0 && elements[0] instanceof Node) {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i].id());
            }
        }
        else if (elements.length > 0 && typeof elements[0] == "number") {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i]);
            }
        }
        // this.elementType = 'node';
    }
    contains(n) {
        return this._elements.indexOf(n.id()) > -1;
    }
    // WRAPPERS TO GENERIC FUNCTIONS IN GRAPH_ELEMENT_QUERY
    highlighted() {
        return new NodeQuery(super.generic_highlighted(), this.g);
    }
    visible() {
        return new NodeQuery(super.generic_visible(), this.g);
    }
    selected() {
        return new NodeQuery(super.generic_selected(), this.g);
    }
    filter(filter) {
        return new NodeQuery(super.generic_filter(filter), this.g);
    }
    presentIn(t1, t2) {
        return new NodeQuery(super.generic_presentIn(t1, t2), this.g);
    }
    sort(attributeName, asc) {
        return super.generic_sort(attributeName, asc);
    }
    // proper functions
    label() {
        const q = new StringQuery();
        for (let i = 0; i < this._elements.length; i++) {
            q.add("" + this.g.attr("label", this._elements[i], "node"));
        }
        return q;
    }
    neighbors(t1, t2) {
        return new NodeQuery(getBulkAttributes("neighbors", this._elements, "node", this.g, t1, t2), this.g);
    }
    links(t1, t2) {
        return new LinkQuery(getBulkAttributes("links", this._elements, "node", this.g, t1, t2), this.g);
    }
    locations(t1, t2) {
        return new LocationQuery(getBulkAttributes("locations", this._elements, "node", this.g, t1, t2), this.g);
    }
    nodeTypes() {
        const q = new StringQuery();
        for (let i = 0; i < this._elements.length; i++) {
            q.add(this.g.attr("nodeType", this._elements[i], "node"));
        }
        return q;
    }
    // returns the i-th element in this query
    get(i) {
        return this.g._nodes[this._elements[i]];
    }
    last() {
        return this.g._nodes[this._elements[this._elements.length - 1]];
    }
    // returns array of nodes
    toArray() {
        const a = [];
        for (let i = 0; i < this._elements.length; i++) {
            a.push(this.g._nodes[this._elements[i]]);
        }
        return a;
    }
    createAttribute(attrName, f) {
        // create and init news attribute array if necessary
        if (this.g.nodeArrays[attrName] == undefined) {
            this.g.nodeArrays[attrName] = [];
            for (let i = 0; i < this.g._nodes.length; i++) {
                this.g.nodeArrays[attrName].push();
            }
        }
        for (let i = 0; i < this._elements.length; i++) {
            this.g.nodeArrays[attrName][this._elements[i]] = f(this.g._nodes[this._elements[i]]);
        }
        return this;
    }
    intersection(q) {
        return new NodeQuery(this.generic_intersection(q)._elements, this.g);
    }
    removeDuplicates() {
        return new NodeQuery(this.generic_removeDuplicates()._elements, this.g);
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this.g.node(this._elements[i]), i);
        }
        return this;
    }
}
/**
 * Represents a node object
 */
export class Node extends BasicElement {
    constructor(id, graph) {
        super(id, "node", graph);
    }
    // SPECIFIC ATTRIBUTE QUERIES
    /** @returns this node's label, specified by the user.
     * If no string value was delivered by the user, returns the ID as string.
     */
    label() {
        return "" + this.attr("label");
    }
    shape() {
        return "" + this.attr("shape");
    }
    color() {
        return "" + this.attr("color");
    }
    nodeType() {
        return this.attr("nodeType");
    }
    /** Returns this nodes neighbors in a NodeQuery. No duplicates.
     * If no parameter is supplied, returns *all* neighbors of this
     * node over all time steps.
     * @param t1 - start time. If only this parameter is specified, returns
     * neighbors in this time step only.
     * @param t2 - end time. If this parameter is specified, returns
     * neighbors between t1 and t2.
     */
    neighbors(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new NodeQuery(this.attr("neighbors")
                .period(t1, t2)
                .toFlatArray(true), this.g);
        }
        if (t1 != undefined) {
            return new NodeQuery(this.attr("neighbors").get(t1), this.g);
        }
        return new NodeQuery(this.attr("neighbors").toFlatArray(), this.g);
    }
    inNeighbors(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new NodeQuery(this.attr("inNeighbors")
                .period(t1, t2)
                .toFlatArray(true), this.g);
        }
        if (t1 != undefined) {
            return new NodeQuery(this.attr("inNeighbors").get(t1), this.g);
        }
        return new NodeQuery(this.attr("inNeighbors").toFlatArray(true), this.g);
    }
    outNeighbors(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new NodeQuery(this.attr("outNeighbors")
                .period(t1, t2)
                .toFlatArray(true), this.g);
        }
        if (t1 != undefined) {
            return new NodeQuery(this.attr("outNeighbors").get(t1), this.g);
        }
        return new NodeQuery(this.attr("outNeighbors").toFlatArray(), this.g);
    }
    links(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new LinkQuery(this.attr("links")
                .period(t1, t2)
                .toFlatArray(true), this.g);
        }
        if (t1 != undefined) {
            return new LinkQuery(this.attr("links").get(t1), this.g);
        }
        return new LinkQuery(this.attr("links").toFlatArray(true), this.g);
    }
    inLinks(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new LinkQuery(this.attr("inLinks")
                .period(t1, t2)
                .toFlatArray(true), this.g);
        }
        if (t1 != undefined) {
            return new LinkQuery(this.attr("inLinks").get(t1), this.g);
        }
        return new LinkQuery(this.attr("inLinks").toFlatArray(true), this.g);
    }
    outLinks(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new LinkQuery(this.attr("outLinks")
                .period(t1, t2)
                .toFlatArray(true), this.g);
        }
        if (t1 != undefined) {
            return new LinkQuery(this.attr("outLinks").get(t1), this.g);
        }
        return new LinkQuery(this.attr("outLinks").toFlatArray(true), this.g);
    }
    locations(t1, t2) {
        if (t2 != undefined && t1 != undefined) {
            return new LocationQuery(this.attr("locations")
                .period(t1, t2)
                .toArray(), this.g);
        }
        if (t1 != undefined) {
            return new LocationQuery([this.attr("locations").get(t1)], this.g);
        }
        return new LocationQuery(this.attr("locations").toArray(), this.g);
    }
    locationSerie(t1, t2) {
        let serie;
        if (t2 != undefined && t1 != undefined)
            serie = this.attr("locations").period(t1, t2);
        // return this.attr('locations').period(t1, t2);
        else if (t1 != undefined)
            serie = this.attr("locations").get(t1);
        // return this.attr('locations').get(t1);
        else
            serie = this.attr("locations");
        // return this.attr('locations');
        const serie2 = serie.getSerie();
        // replace numbers by locations
        const serie3 = new ScalarTimeSeries();
        for (const t in serie2) {
            const time = this.g.time(parseInt(t));
            const location = this.g.location(serie2[t]);
            if (time != undefined && location != undefined) {
                serie3.set(time, location);
            }
        }
        return serie3;
    }
    linksBetween(n) {
        const links = this.links().toArray();
        const finalLinks = [];
        let l;
        for (let i = 0; i < links.length; i++) {
            l = links[i];
            if (l.source == n || l.target == n)
                finalLinks.push(l);
        }
        return new LinkQuery(finalLinks, this.g);
    }
}
export class LinkQuery extends GraphElementQuery {
    //elementType = 'link';
    constructor(elements, g) {
        super(elements, g, "link");
        if (elements.length > 0 && elements[0] instanceof Link) {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i].id());
            }
        }
        if (elements.length > 0 && typeof elements[0] == "number") {
            this._elements = [];
            for (let i = 0; i < elements.length; i++) {
                this._elements.push(elements[i]);
            }
        }
    }
    contains(l) {
        return this._elements.indexOf(l.id()) > -1;
    }
    highlighted() {
        return new LinkQuery(super.generic_highlighted(), this.g);
    }
    visible() {
        return new LinkQuery(super.generic_visible(), this.g);
    }
    selected() {
        return new LinkQuery(super.generic_selected(), this.g);
    }
    filter(filter) {
        return new LinkQuery(super.generic_filter(filter), this.g);
    }
    presentIn(t1, t2) {
        return new LinkQuery(super.generic_presentIn(t1, t2), this.g);
    }
    sort(attributeName) {
        return super.generic_sort(attributeName);
    }
    // returns the i-th element in this query
    get(i) {
        return this.g._links[this._elements[i]];
    }
    last() {
        return this.g._links[this._elements[this._elements.length - 1]];
    }
    // returns array of links
    toArray() {
        const a = [];
        for (let i = 0; i < this._elements.length; i++) {
            a.push(this.g._links[this._elements[i]]);
        }
        return a;
    }
    weights(start, end) {
        const s = new NumberQuery();
        for (let i = 0; i < this._elements.length; i++) {
            const gLink = this.g.link(i);
            if (gLink != undefined)
                s.addAll(gLink.weights(start, end).toArray());
            // ELSE ???
        }
        return s;
    }
    createAttribute(attrName, f) {
        // create and init new attribute array if necessary
        if (this.g.linkArrays[attrName] == undefined) {
            this.g.linkArrays[attrName] = [];
            for (let i = 0; i < this.g._links.length; i++) {
                this.g.linkArrays[attrName].push();
            }
        }
        for (let i = 0; i < this._elements.length; i++) {
            this.g.linkArrays[attrName][this._elements[i]] = f(this.g._links[this._elements[i]]);
        }
        return this;
    }
    linkTypes() {
        const linkTypes = [];
        let s;
        for (let i = 0; i < this._elements.length; i++) {
            const gLink = this.g.link(this._elements[i]);
            if (gLink != undefined) {
                s = gLink.linkType();
                if (linkTypes.indexOf(s) == -1)
                    linkTypes.push(s);
            }
            // ELSE ??
        }
        return linkTypes;
    }
    sources() {
        const nodes = [];
        let link;
        for (let i = 0; i < this._elements.length; i++) {
            link = this.g.link(this._elements[i]);
            if (link != undefined) {
                // UNDEFINED??
                if (nodes.indexOf(link.source.id()) == -1)
                    // ID??
                    nodes.push(link.source.id());
            }
        }
        return new NodeQuery(nodes, this.g);
    }
    targets() {
        const nodes = [];
        let link;
        for (let i = 0; i < this._elements.length; i++) {
            link = this.g.link(this._elements[i]);
            if (link != undefined) {
                // UNDEFINED??
                if (nodes.indexOf(link.target.id()) == -1)
                    // ID??
                    nodes.push(link.target.id());
            }
        }
        return new NodeQuery(nodes, this.g);
    }
    intersection(q) {
        return new LinkQuery(this.generic_intersection(q)._elements, this.g);
    }
    removeDuplicates() {
        return new LinkQuery(this.generic_removeDuplicates()._elements, this.g);
    }
    forEach(f) {
        for (let i = 0; i < this._elements.length; i++) {
            f(this.g.link(this._elements[i]), i);
        }
        return this;
    }
}
/**
 * Represents a link object on a WindowGraph
 */
export class Link extends BasicElement {
    constructor(id, graph) {
        super(id, "link", graph);
        this.targetNPO = undefined;
        this.sourceNPO = undefined;
    }
    // SPECIFIC ATTRIBUTE QUERIES
    linkType() {
        return this.attr("linkType");
    }
    get source() {
        return this.g._nodes[this.attr("source")];
    }
    get target() {
        return this.g._nodes[this.attr("target")];
    }
    nodePair() {
        return this.g._nodePairs[this.attr("nodePair")];
    }
    directed() {
        return this.attr("directed");
    }
    other(n) {
        return this.source == n ? this.target : this.source;
    }
    /** Returns this link's weights over time as NumberQuery
     * If no time parameter is supplied, returns *all* weights of this
     * link over all time steps.
     * @param t1 - start time. If only this parameter is specified, returns
     * only the value for t1.
     * @param t2 - end time. If this parameter is specified, returns
     * weights between t1 and t2.
     */
    weights(start, end) {
        if (start == undefined)
            return new NumberQuery(this.attr("weights").toArray());
        if (end == undefined)
            return new NumberQuery([
                this.attr("weights").get(start),
            ]);
        return new NumberQuery(this.attr("weights")
            .period(start, end)
            .toArray());
    }
    presentIn(start, end) {
        const presence = this.weights(start, end).toArray();
        return presence.length > 0;
    }
    /** Returns all times in which this link's weight != 0  */
    times() {
        // var weights:ScalarTimeSeries<number> = <ScalarTimeSeries<number>>this.attr('weights');
        // var times = []
        // var allTimes = this.g.times().toArray();
        // for(var t in weights.serie){
        //     times.push(allTimes[parseInt(t)]);
        // }
        return new TimeQuery(this.attr("presence"), this.g);
    }
}
export class LinkType {
    constructor(id, name, color) {
        this.id = id;
        this.name = name;
        this.color = color;
    }
}
/* Moved from utils to dynamicgraph to eliminate circular dependency */
/* used by dynamicgraph, but not used none of utils*/
export function attributeSort(a, b, attributeName, asc) {
    const value = a.attr(attributeName);
    let result;
    if (typeof value == "string") {
        result = a.attr(attributeName).localeCompare(b.attr(attributeName));
    }
    else if (typeof value == "number") {
        result = b.attr(attributeName) - a.attr(attributeName);
    }
    else {
        result = 0;
    }
    if (asc == false) {
        result = -result;
    }
    return result;
}
/* moved from utils to dynamicgraph */
export class IDCompound {
    constructor() {
        this.nodeIds = [];
        this.linkIds = [];
        this.timeIds = [];
        this.nodePairIds = [];
        this.locationIds = [];
    }
}
/******** MOVED FROM UTILS TO DYNAMICGRAPH *********/
export function copyPropsShallow(source, target) {
    for (const p in source) {
        if (Object.prototype.hasOwnProperty.call(source, p))
            target[p] = source[p];
    }
    return target;
}
export function copyTimeseriesPropsShallow(source, target) {
    for (const q in source) {
        if (Object.prototype.hasOwnProperty.call(source, q)) {
            for (const p in source[q]) {
                if (Object.prototype.hasOwnProperty.call(source[q], p)) {
                    target[q][p] = source[q][p];
                }
            }
        }
    }
    return target;
}
export function copyTimeSeries(arr, ctorFunc) {
    const arrayClone = [];
    for (const elem in arr) {
        arrayClone.push(copyTimeseriesPropsShallow(arr[elem], ctorFunc()));
    }
    return arrayClone;
}
export function compareTypesDeep(a, b, depth) {
    let result = true;
    if (a == null || b == null)
        return a == b;
    if (typeof a != typeof b)
        return false;
    else if (typeof a != "object")
        return true;
    else if (a.constructor !== b.constructor)
        return false;
    else {
        if (depth > 0) {
            for (const key in a) {
                if (key in b &&
                    Object.prototype.hasOwnProperty.call(a, key) &&
                    Object.prototype.hasOwnProperty.call(b, key) &&
                    !compareTypesDeep(a[key], b[key], depth - 1)) {
                    console.log("compareFailed for key", key, a[key], b[key]);
                    result = false;
                }
            }
        }
        return result;
    }
}
export function sortNumber(a, b) {
    return a - b;
}
export function array(value, size) {
    const array = [];
    while (size--)
        array[size] = value;
    return array;
}
export function doubleArray(size1, size2, value) {
    const array = [];
    if (value == undefined)
        value = [];
    const a = [];
    if (size2) {
        while (size2--)
            a[size2] = value;
    }
    while (size1--)
        array[size1] = a.slice(0);
    return array;
}
//# sourceMappingURL=dynamicgraph.js.map