import * as THREE from "three";
export declare function makeAlphaBuffer(array: number[], stretch: number): Float32Array;
export declare function addBufferedHatchedRect(vertexArray: number[][], x: number, y: number, z: number, width: number, height: number, colorArray: number[][], c: number[]): void;
export declare function addBufferedRect(vertexArray: number[][], x: number, y: number, z: number, width: number, height: number, colorArray: number[][], c: number[]): void;
export declare function addBufferedCirlce(vertexArray: number[][], x: number, y: number, z: number, radius: number, colorArray: number[][], c: number[]): void;
export declare function addBufferedDiamond(vertexArray: number[][], x: number, y: number, z: number, width: number, height: number, colorArray: number[][], c: number[]): void;
export declare function createRectFrame(w: number, h: number, color: number, lineThickness: number): THREE.Line;
export declare function createDiagonalCross(w: number, h: number, color: number, lineThickness: number): THREE.Line;
export declare function makeBuffer3f(array: number[][]): Float32Array;
export declare function makeBuffer4f(array: number[][]): Float32Array;
export declare function updateBuffer(buffer: number[], array: number[][], size: number): void;
export declare function createText(string: string, x: number, y: number, z: number, size: number, color: string, weight?: string, align?: string): THREE.Mesh;
export declare function getMousePos(canvas: any, x: any, y: any): Record<"x" | "y", number>;
export declare class WebGL {
    scene: THREE.Scene;
    camera: THREE.OrthographicCamera;
    renderer: THREE.WebGLRenderer;
    canvas: any;
    geometry: THREE.BufferGeometry;
    interactor: any;
    elementQueries: WebGLElementQuery[];
    constructor(params?: Record<string, any>);
    render(): void;
    selectAll(): WebGLElementQuery;
    enableZoom(b?: boolean): void;
    enablePanning(b: boolean): void;
    enableHorizontalPanning(b: boolean): void;
}
export declare function initWebGL(parentId: string, width: number, height: number, params?: Record<string, any>): WebGL;
export declare function setWebGL(scene: THREE.Scene, camera: THREE.OrthographicCamera, renderer: THREE.WebGLRenderer, canvas: any): void;
export declare function selectAll(): WebGLElementQuery;
export declare class WebGLElementQuery {
    dataElements: any[];
    visualElements: any[];
    mesh: THREE.Mesh;
    children: any[];
    scene: THREE.Scene;
    mouseOverHandler: any;
    mouseMoveHandler: any;
    mouseOutHandler: any;
    mouseDownHandler: any;
    mouseUpHandler: any;
    clickHandler: any;
    x: number[];
    y: number[];
    z: number[];
    r: number[];
    fill: string[];
    stroke: string[];
    strokewidth: number[];
    opacity: number[];
    shape: string;
    updateAttributes: boolean;
    updateStyle: boolean;
    IS_SHADER: boolean;
    constructor();
    data(arr: any[]): WebGLElementQuery;
    append(shape: string): WebGLElementQuery;
    push(e: any): WebGLElementQuery;
    getData(i: any): any;
    getVisual(i: any): any;
    get length(): number;
    filter(f: (obj: Record<string, any>, n: number) => boolean): WebGLElementQuery;
    attr(name: string, v: any): WebGLElementQuery;
    style(name: string, v: any): WebGLElementQuery;
    set(): WebGLElementQuery;
    text(v: any): WebGLElementQuery;
    on(event: string, f: (this: any, event: any, d: any) => void): WebGLElementQuery;
    call(method: string, dataElement: any, event: any): WebGLElementQuery;
    setAttr(element: THREE.Mesh, attr: string, v: any, index: number): void;
    removeAll(): void;
}
export declare function setStyle(element: any, attr: string, v: any, query: WebGLElementQuery): void;
export declare function setText(mesh: any, text: string, parConfig?: any): void;
export declare function setX1(mesh: THREE.Mesh, v: any): void;
export declare function setY1(mesh: THREE.Mesh, v: any): void;
export declare function setX2(mesh: THREE.Mesh, v: any): void;
export declare function setY2(mesh: THREE.Mesh, v: any): void;
export declare function createG(dataElements: any[], scene: THREE.Scene): GroupElement[];
export declare class GroupElement {
    position: {
        x: number;
        y: number;
        z: number;
    };
    children: any;
}
export declare function createCirclesNoShader(dataElements: any[], scene: THREE.Scene): any[];
export declare function createCirclesWithBuffers(query: WebGLElementQuery, scene: THREE.Scene): WebGLElementQuery;
export declare function createRectangles(dataElements: any[], scene: THREE.Scene): any[];
export declare function createPaths(dataElements: any[], scene: THREE.Scene): any[];
export declare function createPolygons(dataElements: any[], scene: THREE.Scene): any[];
export declare function createLines(dataElements: any[], scene: THREE.Scene): any[];
export declare function createWebGLText(dataElements: any[], scene: THREE.Scene): any[];
export declare function createPath(mesh: THREE.Mesh, points: any[]): void;
export declare function createPolygon(mesh: THREE.Mesh, points: THREE.Vector2[]): void;
export declare class WebGLInteractor {
    scene: any;
    canvas: any;
    camera: any;
    raycaster: any;
    mouse: any[];
    mouseStart: any[];
    mouseDown: boolean;
    cameraStart: any[];
    panOffset: any[];
    lastIntersectedSelections: any[];
    lastIntersectedElements: any[];
    isPanEnabled: boolean;
    isHorizontalPanEnabled: boolean;
    isLassoEnabled: boolean;
    lassoPoints: any[];
    lassoStartHandler: any;
    lassoMoveHandler: any;
    lassoEndHandler: any;
    mouseOverSelections: WebGLElementQuery[];
    mouseMoveSelections: WebGLElementQuery[];
    mouseOutSelections: WebGLElementQuery[];
    mouseDownSelections: WebGLElementQuery[];
    mouseUpSelections: WebGLElementQuery[];
    clickSelections: WebGLElementQuery[];
    constructor(scene: THREE.Scene, canvas: HTMLCanvasElement, camera: THREE.Camera);
    register(selection: WebGLElementQuery, method: string): void;
    addEventListener(eventName: string, f: (points: any[]) => void): void;
    mouseMoveHandler(e: any): void;
    clickHandler(e: any): void;
    mouseDownHandler(e: any): void;
    mouseUpHandler(e: any): void;
    intersect(selection: WebGLElementQuery, mousex?: any, mousey?: any): any[];
    intersectCircles(selection: WebGLElementQuery): any[];
    intersectRects(selection: WebGLElementQuery): any[];
    intersectPaths(selection: WebGLElementQuery): any[];
}
export declare function mouseToWorldCoordinates(mouseX: any, mouseY: any): number[];
export declare function curve(points: any[]): any[];
export declare class CheckBox {
    selected: boolean;
    changeCallBack: () => void;
    circle: any;
    frame: any;
    constructor();
    attr(attrName: string, value: any): CheckBox | undefined;
    on(eventType: string, fn: () => void): void;
}
export declare class THREEx {
    canvas: any;
    context: any;
    texture: any;
    /**
     * create a dynamic texture with a underlying canvas
     *
     * @param {Number} width  width of the canvas
     * @param {Number} height height of the canvas
     */
    constructor(width: number, height: number);
    /**
     * clear the canvas
     *
     * @param  {String*} fillStyle 		the fillStyle to clear with, if not provided, fallback on .clearRect
     * @return {THREEx.DynamicTexture}      the object itself, for chained texture
     */
    clear(fillStyle?: any): THREEx;
    /**
     * draw text
     *
     * @param  {String}		text	the text to display
     * @param  {Number|undefined}	x	if provided, it is the x where to draw, if not, the text is centered
     * @param  {Number}		y	the y where to draw the text
     * @param  {String*} 		fillStyle the fillStyle to clear with, if not provided, fallback on .clearRect
     * @param  {String*} 		contextFont the font to use
     * @return {THREEx.DynamicTexture}	the object itself, for chained texture
     */
    drawText(text: string, x: number | undefined, y: number, fillStyle?: string, contextFont?: string): THREEx;
    drawTextCooked(text: string, options: any): THREEx;
    /**
     * execute the drawImage on the internal context
     * the arguments are the same the official context2d.drawImage
     */
    drawImage(...args: any): THREEx;
}
export declare function length(v1: any[]): number;
export declare function normalize(v: number[]): number[];
export declare function setLength(v: number[], l: number): number[];
